<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Home Bill Tracker</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<style>
:root {
  --bg: #0e0e11;
  --card: #1b1b20;
  --text: #f5f5f7;
  --muted: #9a9aa0;
  --accent1: #0a84ff;
  --accent2: #ff375f;
  --danger: #ff453a;
  --radius: 18px;
}

* {
  box-sizing: border-box;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  padding: 20px;
}

.container {
  max-width: 900px;
  margin: auto;
}

h1 {
  text-align: center;
  margin-bottom: 6px;
}

.balance {
  text-align: center;
  color: var(--muted);
  margin-bottom: 16px;
  display: flex; /* Make it a flex container */
  flex-direction: column; /* Stack items vertically */
  align-items: center; /* Center horizontally */
  gap: 8px; /* Space between text and button */
}

/* Style for the new settlement action button */
.balance .action-button {
  background: #2a2a31; /* Slightly darker than card for contrast, or similar to month tabs */
  color: var(--accent1);
  padding: 6px 16px; /* A little more horizontal padding for better look, but still compact */
  border-radius: 10px;
  font-weight: 500; /* Slightly less bold than main buttons */
  font-size: 0.85rem;
  cursor: pointer;
  border: none; /* Remove border */
  display: inline-flex;
  align-items: center;
  justify-content: center; /* Center icon and text within the button */
  gap: 6px;
  width: auto; /* Explicitly ensure it's not 100% width */
  box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* Subtle shadow for depth */
}

.balance .action-button:hover {
  background: #3a3a41;
}


.card {
  background: var(--card);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 16px;
}

.chart-wrapper {
  max-width: 520px;
  margin: 0 auto;
}

canvas {
  max-height: 160px;
}

/* MONTH AND YEAR TABS */
.month-tabs, .year-tabs {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  justify-content: center;
  margin-bottom: 8px; /* Space between year and month tabs */
}

.month-tab, .year-tab {
  padding: 8px 14px;
  border-radius: 14px;
  background: #2a2a31;
  font-size: 0.85rem;
  cursor: pointer;
  white-space: nowrap;
}

.month-tab.active, .year-tab.active {
  background: var(--accent1);
}

/* New: View Switcher */
.view-switcher {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 15px; /* Space between buttons and text */
  margin-top: 10px; /* Space from profiles */
  margin-bottom: 10px; /* Space to chart card */
  color: var(--muted);
  font-size: 0.9rem;
}

.view-switcher button {
  background: none;
  border: none;
  color: var(--muted);
  padding: 5px;
  cursor: pointer;
  font-size: 1.2rem;
  width: auto; /* Override general button width */
}

.view-switcher button:hover {
  color: var(--text);
}


/* FORM */
.form {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr auto;
  gap: 8px;
}

@media (max-width: 600px) {
  .form {
    grid-template-columns: 1fr;
  }
}

input, select {
  background: #2a2a31;
  border: none;
  border-radius: 14px;
  padding: 12px;
  color: var(--text);
  width: 100%;
}

button {
  border: none;
  border-radius: 14px;
  padding: 12px 18px;
  background: var(--accent1);
  color: white;
  font-weight: 600;
  cursor: pointer;
  width: 100%;
}

button:active {
  opacity: 0.85;
}

/* EXPENSE LIST */
.expense {
  display: flex;
  flex-wrap: wrap; /* Allow items to wrap to the next line */
  justify-content: space-between;
  align-items: center;
  padding: 10px 0;
  border-bottom: 1px solid #2a2a31;
}

.expense-left {
  display: flex;
  align-items: center;
  gap: 8px;
}

.logo {
  width: 20px;
  height: 20px;
  border-radius: 4px;
}

/* Generic receipt icon style when no specific logo */
.expense-left .fa-receipt {
  font-size: 20px; /* Match logo size */
  width: 20px;
  text-align: center;
}


.actions {
  display: flex;
  gap: 10px;
  align-items: center; /* Align items vertically */
}

.action {
  font-size: 0.8rem; /* Keep a base size for icons */
  cursor: pointer;
  display: flex; /* Make actions flex to center icon if needed */
  align-items: center;
  justify-content: center;
}

.action.delete {
  color: var(--danger);
}

/* New CSS for the chevron expand/collapse icon */
.expand-chart-toggle i {
  transition: transform 0.2s ease-in-out;
}

.expand-chart-toggle.expanded i {
  transform: rotate(180deg);
}

/* New CSS for the individual expense chart container */
.expense-chart-container {
  width: 100%; /* Take full width of its parent (.expense) */
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px dashed #2a2a31; /* Subtle separator */
  max-width: 100%; /* Ensure it doesn't overflow */
}

.expense-chart-container canvas {
  max-height: 120px; /* Limit height of individual expense charts */
  width: 100% !important; /* Override Chart.js default inline width */
  height: auto !important; /* Override Chart.js default inline height */
}

/* Recurring icon specific styling */
.recurring-indicator {
    color: var(--accent1); /* Use accent color for visibility */
    margin-left: 5px; /* Small space from the note text */
    font-size: 0.75rem; /* Slightly smaller than note text */
}

/* PROFILES */
.profiles {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 24px;
  margin-top: 12px;
  margin-bottom: 16px;
}

.profile {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  border: 3px solid transparent;
  cursor: pointer;
}

.profile.active {
  border-color: var(--accent1);
}

/* EXPORT/IMPORT BUTTONS */
.export {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px; /* Gap between buttons */
}

.export button {
  display: flex; /* Allows icon and text to be on the same line and align */
  align-items: center;
  justify-content: center; /* This will center the icon and text horizontally */
  gap: 8px; /* Gap between icon and text */
}

/* Auto-suggestion Styles */
.note-input-wrapper {
  position: relative; /* Crucial for positioning the dropdown */
}

.suggestions-dropdown {
  position: absolute;
  top: calc(100% + 5px); /* Position below the input + a small gap */
  left: 0;
  right: 0;
  background: var(--card);
  border-radius: 10px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  max-height: 120px;
  overflow-y: auto;
  z-index: 100; /* Ensure it's above other elements */
  display: none; /* Hidden by default */
  width: 100%; /* Ensure it spans the width of the input */
}

.suggestions-dropdown div {
  padding: 8px 12px;
  cursor: pointer;
}

.suggestions-dropdown div:hover {
  background: #2a2a31;
}

/* New CSS for the expense header and avatar */
.expense-header-content {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px; /* Space between title and separator */
  font-weight: 600; /* Make the title text bold like the original strong tag */
}

.expense-header-avatar {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  object-fit: cover; /* Ensure image covers the area nicely */
}

.expense-separator {
  border-bottom: 1px solid #2a2a31;
  margin-bottom: 10px; /* Space between separator and first expense item */
}
</style>
</head>

<body>
<div class="container">

<h1>Bills Overview</h1>
<div class="balance" id="balanceText"></div>

<div class="profiles">
  <img src="assets/person001.png" id="francisBtn" class="profile active" onclick="selectPerson('francis')">
  <img src="assets/person002.png" id="fionaBtn" class="profile" onclick="selectPerson('fiona')">
</div>

<!-- New: View Switcher -->
<div class="view-switcher">
  <button id="prevViewBtn" onclick="toggleViewMode()"><i class="fa-solid fa-chevron-left"></i></button>
  <span id="currentViewText">Monthly View</span>
  <button id="nextViewBtn" onclick="toggleViewMode()"><i class="fa-solid fa-chevron-right"></i></button>
</div>

<div class="card">
  <div class="chart-wrapper">
    <canvas id="billChart"></canvas>
  </div>
</div>

<div class="card">
  <div class="year-tabs" id="yearTabs"></div>
  <div class="month-tabs" id="monthTabs"></div>
</div>

<div class="card">
  <div class="form">
    <input id="amountInput" type="number" step="0.01" placeholder="£ amount">
    <div class="note-input-wrapper">
      <input id="noteInput" type="text" placeholder="Description or brand">
      <div id="suggestions" class="suggestions-dropdown"></div>
    </div>
    <select id="recurringInput">
      <option value="no">One-off</option>
      <option value="yes">Recurring</option>
    </select>
    <button onclick="addExpense()">Add</button>
  </div>
</div>

<div class="card">
  <!-- Changed to a div to hold avatar, text, and separator -->
  <div id="expenseHeader"></div>
  <div id="expenseList"></div>
</div>

<div class="card export">
  <button onclick="importJSON()">
    <i class="fa-solid fa-file-arrow-up"></i> Import JSON
  </button>
  <button onclick="exportJSON()">
    <i class="fa-solid fa-file-arrow-down"></i> Export JSON
  </button>
</div>

</div>

<script>
const MONTHS = ["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];

// Canonical list of brands for auto-suggestions, sorted alphabetically
const SUGGESTION_BRANDS = [
    "affinity water", "amazon", "b&q", "barclays", "british airways", "costco", "council tax", "eurostar",
    "hotel", "hsbc", "hyperoptic", "iberia", "insite energy", "john lewis", "lidl", "lner", "m&s",
    "octopus energy", "renfe", "revolut", "ryanair", "sainsbury's", "tfl", "accommodation"
].sort();

// Rules for logo detection (more comprehensive, order might matter for precedence)
const BRAND_LOGO_RULES = [
  { keywords: ["affinity water"], logo: "assets/logos/affinitywater.png" },
  { keywords: ["amazon"], logo: "assets/logos/amazon.png" },
  { keywords: ["b&q"], logo: "assets/logos/bandq.png" },
  { keywords: ["barclays"], logo: "assets/logos/barclays.png" },
  { keywords: ["british airways"], logo: "assets/logos/britishairways.png" },
  { keywords: ["costco"], logo: "assets/logos/costco.png" },
  { keywords: ["hyperoptic"], logo: "assets/logos/hyperoptic.png" },
  { keywords: ["hsbc"], logo: "assets/logos/hsbc.png" },
  { keywords: ["iberia"], logo: "assets/logos/iberia.png" },
  { keywords: ["insite energy"], logo: "assets/logos/insiteenergy.png" },
  { keywords: ["john lewis"], logo: "assets/logos/johnlewis.png" },
  { keywords: ["lidl"], logo: "assets/logos/lidl.png" },
  { keywords: ["lner"], logo: "assets/logos/lner.png" },
  { keywords: ["m&s"], logo: "assets/logos/mands.png" }, // Handles M&S
  { keywords: ["octopus energy"], logo: "assets/logos/octopusenergy.png" }, // Handles Octopus Energy
  { keywords: ["renfe"], logo: "assets/logos/renfe.png" },
  { keywords: ["revolut"], logo: "assets/logos/revolut.png" },
  { keywords: ["ryanair"], logo: "assets/logos/ryanair.png" },
  { keywords: ["sainsbury's"], logo: "assets/logos/sainsburys.png" },
  { keywords: ["tfl"], logo: "assets/logos/tfl.png" }, // Handles TFL
  { keywords: ["eurostar"], logo: "assets/logos/eurostar.png" },
  // Specific aliases for Council Tax (prioritize more specific matches if possible)
  { keywords: ["council tax", "council-tax", "brent council", "brent"], logo: "assets/logos/brent.png" },
  // Generic catch-all for hotels/accommodation (place after specific hotel brands if they were ever added)
  { keywords: ["hotel", "accommodation", "booking.com"], logo: "assets/logos/booking.png" }
];


// DOM elements for suggestions
const noteInput = document.getElementById('noteInput');
const suggestionsDiv = document.getElementById('suggestions');
const yearTabsDiv = document.getElementById('yearTabs'); // New DOM element for year tabs
const expenseHeaderDiv = document.getElementById('expenseHeader'); // Get the new expense header div
const balanceTextDiv = document.getElementById('balanceText'); // Get the balance text div for dynamic content
const currentViewTextSpan = document.getElementById('currentViewText'); // Get the span for view mode text

const expenseChartInstances = {}; // Stores Chart.js instances for individual expenses by originalIndex

// Auto-suggestion functions
function showSuggestions() {
  const inputValue = noteInput.value.toLowerCase();
  suggestionsDiv.innerHTML = ''; // Clear previous suggestions

  // Only show suggestions if there's input or if the input is focused and the dropdown is not explicitly hidden
  if (inputValue.length === 0 && document.activeElement !== noteInput) {
    suggestionsDiv.style.display = 'none';
    return;
  }

  const matchingBrands = SUGGESTION_BRANDS.filter(brand =>
    brand.includes(inputValue)
  );

  if (matchingBrands.length > 0) {
    matchingBrands.forEach(brand => {
      const suggestionItem = document.createElement('div');
      // Capitalize for display, e.g., "affinity water" -> "Affinity Water"
      // Special handling for M&S, B&Q, HSBC, LNER, and TFL
      let displayText = brand.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
      if (brand === "m&s") displayText = "M&S";
      if (brand === "b&q") displayText = "B&Q";
      if (brand === "hsbc") displayText = "HSBC"; // Make HSBC uppercase
      if (brand === "lner") displayText = "LNER"; // Make LNER uppercase
      if (brand === "tfl") displayText = "TFL";   // Make TFL uppercase

      suggestionItem.textContent = displayText;
      suggestionItem.onmousedown = (event) => { // Use mousedown and preventDefault
        event.preventDefault(); // Prevents the input from losing focus
        selectSuggestion(brand);
      };
      suggestionsDiv.appendChild(suggestionItem);
    });
    suggestionsDiv.style.display = 'block';
  } else {
    suggestionsDiv.style.display = 'none';
  }
}

function selectSuggestion(brandName) {
  // Set input to selected capitalized brand (more robust capitalization)
  let capitalizedBrand = brandName.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
  if (brandName === "m&s") capitalizedBrand = "M&S";
  if (brandName === "b&q") capitalizedBrand = "B&Q";
  if (brandName === "hsbc") capitalizedBrand = "HSBC"; // Make HSBC uppercase
  if (brandName === "lner") capitalizedBrand = "LNER"; // Make LNER uppercase
  if (brandName === "tfl") capitalizedBrand = "TFL";   // Make TFL uppercase

  noteInput.value = capitalizedBrand;
  suggestionsDiv.style.display = 'none';
  // No need to call focus() here, as preventDefault on mousedown kept focus
}

function hideSuggestions() {
  // Delay hiding to allow click events on suggestions to register
  setTimeout(() => {
    // Only hide if the input does not have focus AND the dropdown itself is not focused
    if (document.activeElement !== noteInput && !suggestionsDiv.contains(document.activeElement)) {
      suggestionsDiv.style.display = 'none';
    }
  }, 100);
}

// Attach event listeners
noteInput.addEventListener('input', showSuggestions);
noteInput.addEventListener('focus', showSuggestions); // Show suggestions if input is focused and has text
noteInput.addEventListener('blur', hideSuggestions);


function normalizeMonthKey(monthKey) {
  if (monthKey && monthKey.match(/^\d{4}-\d{2}$/)) { // e.g., "2026-01"
    const [year, monthNum] = monthKey.split('-');
    const monthIndex = parseInt(monthNum, 10) - 1; // 0-indexed month
    if (monthIndex >= 0 && monthIndex < 12) {
      return `${year}-${MONTHS[monthIndex]}`;
    }
  }
  return monthKey; // Return as is if already correct or unparseable
}

function currentMonthKey() {
  const d = new Date();
  return `${d.getFullYear()}-${MONTHS[d.getMonth()]}`;
}

// Initialize activeYear and activeMonth
const today = new Date();
let activeYear = today.getFullYear();
let activeMonth = `${activeYear}-${MONTHS[today.getMonth()]}`;

let activePerson = "francis";
let viewMode = 'monthly'; // 'monthly' or 'annual'


const data = JSON.parse(localStorage.getItem("billData")) || {
  francis: [],
  fiona: [],
  settlements: {} // Initialize settlements here
};
// Ensure settlements object exists even if loaded from older data structure
if (!data.settlements) {
    data.settlements = {};
    save(); // Save the updated structure to localStorage
}


// Migrate old month formats to the new YYYY-MMM format on load
function migrateData() {
  let changed = false;
  ["francis", "fiona"].forEach(p => {
    data[p].forEach(e => {
      const normalized = normalizeMonthKey(e.month);
      if (normalized !== e.month) {
        e.month = normalized;
        changed = true;
      }
    });
  });
  if (changed) {
    save(); // Save the migrated data back to localStorage
    console.log("Migrated old month formats in localStorage.");
  }
}

// Function to ensure data integrity for baseId and recurring flags
function normalizeExpenseData() {
    let changed = false;
    ["francis", "fiona"].forEach(p => {
        // Map to store baseId for recurring expenses with the same note
        const recurringNoteToBaseIdMap = {};

        data[p].forEach(e => {
            // Ensure `recurring` is a proper boolean
            const wasRecurringString = e.recurring === "yes";
            e.recurring = (e.recurring === true || wasRecurringString);
            if (wasRecurringString) changed = true; // Mark as changed if we converted "yes"

            if (e.recurring) {
                if (!e.baseId) {
                    // If no baseId, check if we've seen this note as recurring before
                    if (recurringNoteToBaseIdMap[e.note]) {
                        e.baseId = recurringNoteToBaseIdMap[e.note];
                    } else {
                        e.baseId = crypto.randomUUID();
                        recurringNoteToBaseIdMap[e.note] = e.baseId;
                    }
                    changed = true;
                } else {
                    // If it has a baseId, ensure it's also in the map for future matching
                    recurringNoteToBaseIdMap[e.note] = e.baseId;
                }
            } else {
                // Non-recurring expenses should not have a baseId for projection logic
                if (e.baseId) {
                    delete e.baseId;
                    changed = true;
                }
            }
        });
    });
    if (changed) {
        save();
        console.log("Normalized expense data (baseId and recurring flags).");
    }
}


function save() {
  localStorage.setItem("billData", JSON.stringify(data));
}

function capitalise(name) {
  return name.charAt(0).toUpperCase() + name.slice(1);
}

// Updated detectLogo to use BRAND_LOGO_RULES for more flexible matching
function detectLogo(note) {
  const lowerCaseNote = note.toLowerCase();
  for (const rule of BRAND_LOGO_RULES) {
    for (const keyword of rule.keywords) {
      if (lowerCaseNote.includes(keyword)) {
        return rule.logo;
      }
    }
  }
  return null;
}

// New function to update logos for all existing expenses
function updateLogosForAllExpenses() {
  let changed = false;
  ["francis", "fiona"].forEach(p => {
    data[p].forEach(e => {
      const newLogo = detectLogo(e.note);
      if (e.logo !== newLogo) { // Only update if the logo has changed
        e.logo = newLogo;
        changed = true;
      }
    });
  });
  if (changed) {
    save();
    console.log("Updated logos for existing expenses based on new rules.");
  }
}

function getYears() {
  const years = new Set();
  // Add current year
  years.add(new Date().getFullYear().toString());

  // Add years from existing data
  ["francis", "fiona"].forEach(p => {
    data[p].forEach(e => {
      if (e.month) {
        years.add(e.month.substring(0, 4)); // Extract YYYY from YYYY-MMM
      }
    });
  });
  return [...years].sort((a, b) => parseInt(a) - parseInt(b));
}

function renderYears() {
  yearTabsDiv.innerHTML = "";
  getYears().forEach(year => {
    const tab = document.createElement("div");
    tab.className = "year-tab" + (year === activeYear.toString() ? " active" : "");
    tab.textContent = year;
    tab.onclick = () => {
      activeYear = parseInt(year);
      // Try to keep the same month, but for the new year
      const currentMonthAbbr = activeMonth.substring(5, 8); // e.g., "JAN" from "2026-JAN"
      activeMonth = `${activeYear}-${currentMonthAbbr}`;
      applyRecurring(); // Re-apply recurring for the new year's current month
      updateAll(); // Call updateAll to refresh all UI elements
    };
    yearTabsDiv.appendChild(tab);
  });
}

function renderMonths() {
  monthTabs.innerHTML = "";
  MONTHS.forEach(m => {
    const tab = document.createElement("div");
    tab.className = "month-tab" + ((`${activeYear}-${m}`) === activeMonth ? " active" : "");
    tab.textContent = m; // Display only the month abbreviation
    tab.onclick = () => {
      activeMonth = `${activeYear}-${m}`; // Set activeMonth with full YYYY-MMM
      applyRecurring();
      updateAll(); // Call updateAll to refresh all UI elements
    };
    monthTabs.appendChild(tab);
  });
}

// New function to mark a month as settled or unsettled
function markMonthAsSettled(status) {
  data.settlements[activeMonth] = status;
  save();
  updateAll();
}

function total(person) {
  return data[person]
    .filter(e => normalizeMonthKey(e.month) === activeMonth) // Normalize month for filtering
    .reduce((s,e) => s + e.amount, 0);
}

// New function to calculate annual totals including projected recurring expenses
function calculateAnnualTotals() {
    const annualTotals = { francis: 0, fiona: 0 };
    const yearPrefix = activeYear.toString();

    ["francis", "fiona"].forEach(personKey => {
        const personExpenses = data[personKey];
        // Use a structure to track the latest amount for each recurring baseId *across all months*
        const latestRecurringAmounts = {}; // { baseId: amount }

        // First pass: Find the latest amount for each unique recurring baseId
        personExpenses.forEach(e => {
            if (e.recurring && e.baseId) {
                latestRecurringAmounts[e.baseId] = e.amount;
            }
        });

        // Loop through each month (JAN-DEC) of the active year
        for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
            const monthOfYear = MONTHS[monthIndex];
            const currentYearMonthKey = `${yearPrefix}-${monthOfYear}`;
            let monthlyProjectedTotal = 0;

            const existingExpensesForThisMonth = personExpenses.filter(e => e.month === currentYearMonthKey);
            const recurringBaseIdsExplicitlyIncludedThisMonth = new Set();

            // Add all expenses explicitly recorded for this specific month
            existingExpensesForThisMonth.forEach(e => {
                monthlyProjectedTotal += e.amount;
                if (e.recurring && e.baseId) {
                    recurringBaseIdsExplicitlyIncludedThisMonth.add(e.baseId);
                }
            });

            // For any unique recurring expenses that *have not been explicitly recorded* for this specific month,
            // add their latest known amount to the monthly projected total.
            // This ensures full annual projection even for unvisited months.
            Object.keys(latestRecurringAmounts).forEach(baseId => {
                if (!recurringBaseIdsExplicitlyIncludedThisMonth.has(baseId)) {
                    monthlyProjectedTotal += latestRecurringAmounts[baseId];
                }
            });
            annualTotals[personKey] += monthlyProjectedTotal;
        }
    });

    return annualTotals;
}


function updateBalance() {
  const a = total("francis");
  const b = total("fiona");
  const diff = Math.abs(a - b) / 2;

  let balanceMessage = "";
  let actionButton = "";

  const isSettled = data.settlements[activeMonth];

  if (isSettled) {
    balanceMessage = `All settled for ${activeMonth}!`;
    actionButton = `<button class="action-button" onclick="markMonthAsSettled(false)"><i class="fa-solid fa-undo"></i> Unmark as Settled</button>`;
  } else {
    if (a === b) {
      balanceMessage = "All settled";
      // No action button needed if already balanced
    } else if (a > b) {
      balanceMessage = `Fiona owes Francis £${diff.toFixed(2)}`;
      actionButton = `<button class="action-button" onclick="markMonthAsSettled(true)"><i class="fa-solid fa-check"></i> Mark as Settled</button>`;
    } else {
      balanceMessage = `Francis owes Fiona £${diff.toFixed(2)}`;
      actionButton = `<button class="action-button" onclick="markMonthAsSettled(true)"><i class="fa-solid fa-check"></i> Mark as Settled</button>`;
    }
  }

  balanceTextDiv.innerHTML = `
    <span>${balanceMessage}</span>
    ${actionButton}
  `;
}

function renderExpenses() {
  // Determine avatar src for the active person
  const avatarImgSrc = (activePerson === "francis") ? "assets/person001.png" : "assets/person002.png";

  // Construct the header content including avatar, text, and separator
  expenseHeaderDiv.innerHTML = `
    <div class="expense-header-content">
      <img src="${avatarImgSrc}" class="expense-header-avatar">
      <span>${capitalise(activePerson)} – ${activeMonth}</span>
    </div>
    <div class="expense-separator"></div>
  `;

  // Destroy all existing expense detail charts before clearing the list
  for (const index in expenseChartInstances) {
    if (expenseChartInstances.hasOwnProperty(index)) {
      expenseChartInstances[index].destroy();
    }
  }
  // Clear the map after destroying instances
  Object.keys(expenseChartInstances).forEach(key => delete expenseChartInstances[key]);


  expenseList.innerHTML = ""; // Clear existing expense items

  // Filter to only expenses for the active month, but get their original index
  data[activePerson]
    .filter(e => normalizeMonthKey(e.month) === activeMonth)
    .forEach((e) => {
      const originalIndex = data[activePerson].findIndex(item => item === e);

      const row = document.createElement("div");
      row.className = "expense";
      // The logo or default receipt icon
      const iconContent = e.logo ? `<img class="logo" src="${e.logo}" onerror="this.remove()">` : `<i class="fa-solid fa-receipt"></i>`;
      
      // Add recurring indicator if applicable
      const recurringIndicator = e.recurring ? `<i class="fa-solid fa-repeat recurring-indicator" title="Recurring expense"></i>` : '';

      row.innerHTML = `
        <div class="expense-left">
          ${iconContent}
          <div>${e.note} ${recurringIndicator}<br><small>£${e.amount.toFixed(2)}</small></div>
        </div>
        <div class="actions">
          <span class="action expand-chart-toggle" data-original-index="${originalIndex}" onclick="toggleExpenseChart(this, ${originalIndex})"><i class="fa-solid fa-chevron-down"></i></span>
          <span class="action" onclick="editExpenseAtIndex(${originalIndex})"><i class="fa-solid fa-pencil"></i></span>
          <span class="action delete" onclick="deleteExpenseAtIndex(${originalIndex})"><i class="fa-solid fa-trash"></i></span>
        </div>
        <!-- Chart container, will take full width due to flex-wrap -->
        <div id="expenseChartWrapper_${originalIndex}" class="expense-chart-container" style="display:none;">
          <canvas id="expenseChartCanvas_${originalIndex}"></canvas>
        </div>
      `;
      expenseList.appendChild(row);
    });
}

function addExpense() {
  const amount = parseFloat(amountInput.value);
  const note = noteInput.value.trim();
  if (!amount || !note) return;

  data[activePerson].push({
    baseId: crypto.randomUUID(), // New items always get a fresh baseId
    month: activeMonth, // activeMonth is already in YYYY-MMM format
    amount,
    note,
    logo: detectLogo(note), // detect logo based on the note
    recurring: recurringInput.value === "yes" ? true : false // Ensure boolean
  });

  amountInput.value = "";
  noteInput.value = "";
  suggestionsDiv.style.display = 'none'; // Hide suggestions after adding expense
  save();
  updateAll();
}

// Renamed to avoid confusion, using original index for data manipulation
function editExpenseAtIndex(originalIndex) {
  const e = data[activePerson][originalIndex];
  const n = prompt("Description", e.note);
  const a = prompt("Amount", e.amount);
  if (n === null || a === null) return; // User cancelled prompt
  if (!n || !a) return; // Empty values

  e.note = n;
  e.amount = parseFloat(a);
  e.logo = detectLogo(n); // Re-detect logo in case description changed
  // Note: changing description of a recurring item will effectively create a new "stream" if baseId relies on note
  // For recurring, baseId should ideally remain fixed once set.
  // The normalizeExpenseData function helps re-assign baseIds on load if they are missing or inconsistent.
  save();
  updateAll();
}

// Renamed to avoid confusion, using original index for data manipulation
function deleteExpenseAtIndex(originalIndex) {
  if (!confirm("Delete expense?")) return;
  data[activePerson].splice(originalIndex,1);
  save();
  updateAll();
}

function selectPerson(p) {
  activePerson = p;
  francisBtn.classList.toggle("active", p === "francis");
  fionaBtn.classList.toggle("active", p === "fiona");
  updateAll(); // Update all elements, including re-rendering expenses
}

const chart = new Chart(document.getElementById("billChart"), {
  type: "bar",
  data: {
    labels: ["Francis", "Fiona"],
    datasets: [{
      data: [0,0],
      backgroundColor: ["#0a84ff","#ff375f"]
    }]
  },
  options: {
    indexAxis: "y",
    plugins: { legend: { display: false } },
    scales: {
      x: { ticks: { color: "#f5f5f7" }, grid: { color: "#2a2a31" } },
      y: { ticks: { color: "#f5f5f7" }, grid: { display: false } }
    },
    elements: { // Added for rounded bar corners
      bar: {
        borderRadius: {
          topRight: 12, // Round the top-right corner
          bottomRight: 12 // Round the bottom-right corner
        }
      }
    }
  }
});

function updateChart() {
    let francisAmount, fionaAmount;

    if (viewMode === 'monthly') {
        francisAmount = total("francis"); // This is already specific to activeMonth
        fionaAmount = total("fiona");     // This is already specific to activeMonth
    } else { // viewMode === 'annual'
        const annualTotals = calculateAnnualTotals();
        francisAmount = annualTotals.francis;
        fionaAmount = annualTotals.fiona;
    }

    // Simplified labels as requested
    chart.data.labels = ["Francis", "Fiona"];
    chart.data.datasets[0].data = [francisAmount, fionaAmount];
    chart.update();
}

// New helper function to set the view mode text
function updateViewModeText() {
    if (viewMode === 'monthly') {
        currentViewTextSpan.textContent = "Monthly View";
    } else {
        currentViewTextSpan.textContent = `Annual View (${activeYear})`;
    }
}

// New function to toggle view mode
function toggleViewMode() {
    if (viewMode === 'monthly') {
        viewMode = 'annual';
    } else {
        viewMode = 'monthly';
    }
    updateViewModeText(); // Update the text immediately
    updateChart(); // Just update the chart, no need for full updateAll
}


function exportJSON() {
  const blob = new Blob([JSON.stringify(data,null,2)], { type: "application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "home-bills.json";
  a.click();
}

function importJSON() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json'; // Only accept JSON files

  input.onchange = (event) => {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importedData = JSON.parse(e.target.result);
          // Basic validation: Check if it looks like our data structure
          if (importedData.francis && Array.isArray(importedData.francis) &&
              importedData.fiona && Array.isArray(importedData.fiona)) {
            if (confirm("Are you sure you want to import this data? This will overwrite your current data.")) {
              data.francis = importedData.francis;
              data.fiona = importedData.fiona;
              // Import settlements too, if they exist in the imported data
              data.settlements = importedData.settlements || {};
              save();
              migrateData(); // Run migration on imported data too, to ensure consistency
              normalizeExpenseData(); // Normalize imported data
              updateLogosForAllExpenses(); // Apply new logo rules to imported data
              updateAll();
              alert("Data imported successfully!");
            }
          } else {
            alert("Invalid JSON file format. Please ensure it's a valid Home Bill Tracker export.");
          }
        } catch (error) {
          alert("Error parsing JSON file: " + error.message);
          console.error("Error parsing JSON file:", error);
        }
      };
      reader.readAsText(file);
    }
  };

  input.click(); // Programmatically click the hidden file input to open file dialog
}


function applyRecurring() {
  ["francis","fiona"].forEach(p => {
    data[p].forEach(e => {
      // If it's a recurring expense, and it has a baseId (should be true after normalizeExpenseData)
      // and there isn't already an entry for this specific recurring item in the activeMonth, add one.
      if (e.recurring && e.baseId && !data[p].some(x => x.baseId === e.baseId && x.month === activeMonth)) {
        data[p].push({
            // Create a *new* object, but inherit properties from the original recurring item
            ...e,
            // Assign a new, unique ID for this specific monthly instance
            id: crypto.randomUUID(), // Each instance of a recurring bill needs a unique ID for editing/deleting
            month: activeMonth,
            // The amount and note are inherited, meaning if the original recurring item's amount changes,
            // subsequent auto-added monthly entries will reflect that.
            // If the user edits an auto-added monthly entry, it becomes an explicit entry for that month.
        });
      }
    });
  });
  save(); // Save after potentially adding new recurring entries
}

/**
 * Toggles the visibility of an expense's history chart and renders/destroys it.
 * @param {HTMLElement} toggleButtonElement The element that was clicked (the span with the chevron).
 * @param {number} originalIndex The original index of the expense in the data[activePerson] array.
 */
function toggleExpenseChart(toggleButtonElement, originalIndex) {
  const chartWrapper = document.getElementById(`expenseChartWrapper_${originalIndex}`);
  const chevronIcon = toggleButtonElement.querySelector('i');

  if (chartWrapper.style.display === 'none') {
    // Expand chart
    chartWrapper.style.display = 'block';
    toggleButtonElement.classList.add('expanded');
    drawExpenseHistoryChart(data[activePerson][originalIndex], `expenseChartCanvas_${originalIndex}`, originalIndex);
  } else {
    // Collapse chart
    chartWrapper.style.display = 'none';
    toggleButtonElement.classList.remove('expanded');
    // Destroy chart instance when collapsing to free memory
    if (expenseChartInstances[originalIndex]) {
      expenseChartInstances[originalIndex].destroy();
      delete expenseChartInstances[originalIndex];
    }
  }
}

/**
 * Gathers expense data for a specific item across all months of the active year.
 * This function is now responsible for *projecting* recurring expenses
 * for months where they haven't been explicitly recorded.
 *
 * @param {object} currentExpense The expense object to track (e.g., { baseId: ..., note: ... }).
 * @param {string} personKey 'francis' or 'fiona'.
 * @param {number} year The active year (e.g., 2023).
 * @returns {Array<number>} An array of 12 numbers, representing total amount for each month.
 */
function getExpenseHistoryData(currentExpense, personKey, year) {
    const amountsByMonth = new Array(12).fill(0);
    const yearPrefix = year.toString();

    // Determine the identifier for matching across months
    // Use baseId for recurring items, and note for one-off items.
    const matcherId = currentExpense.recurring && currentExpense.baseId ? currentExpense.baseId : currentExpense.note;

    // First, collect all *explicitly recorded* expenses for this item in the active year
    const explicitMonthlyAmounts = {}; // { 'YYYY-MMM': totalAmountForThatMonth }

    data[personKey].filter(e => {
        const expenseYear = e.month.substring(0, 4);
        const eMatcherId = e.recurring && e.baseId ? e.baseId : e.note;
        return expenseYear === yearPrefix && eMatcherId === matcherId;
    }).forEach(e => {
        if (!explicitMonthlyAmounts[e.month]) {
            explicitMonthlyAmounts[e.month] = 0;
        }
        explicitMonthlyAmounts[e.month] += e.amount;
    });

    // Now, populate the 12-month array, projecting recurring amounts where explicit entries are missing
    for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
        const monthKey = `${yearPrefix}-${MONTHS[monthIndex]}`;
        if (explicitMonthlyAmounts[monthKey] !== undefined) {
            // Use the explicitly recorded amount(s) for this month
            amountsByMonth[monthIndex] = explicitMonthlyAmounts[monthKey];
        } else if (currentExpense.recurring) {
            // If it's a recurring expense and no explicit entry, project its current amount
            amountsByMonth[monthIndex] = currentExpense.amount;
        }
        // If it's non-recurring and no explicit entry, it remains 0 (already initialized)
    }
    return amountsByMonth;
}


/**
 * Draws or updates the individual expense history chart.
 * @param {object} expense The expense object being charted.
 * @param {string} canvasId The ID of the canvas element.
 * @param {number} originalIndex The original index of the expense for instance tracking.
 */
function drawExpenseHistoryChart(expense, canvasId, originalIndex) {
  const ctx = document.getElementById(canvasId);

  // Destroy existing chart instance if it exists before creating a new one
  if (expenseChartInstances[originalIndex]) {
    expenseChartInstances[originalIndex].destroy();
  }

  const amounts = getExpenseHistoryData(expense, activePerson, activeYear);

  expenseChartInstances[originalIndex] = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: MONTHS,
      datasets: [{
        data: amounts,
        backgroundColor: (context) => {
          // Use direct hex code for robustness
          return context.raw > 0 ? '#0a84ff' : 'transparent';
        },
        borderColor: 'transparent',
        borderRadius: 4,
        barPercentage: 0.8,
        categoryPercentage: 0.8
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              let label = context.dataset.label || '';
              if (label) {
                label += ': ';
              }
              if (context.parsed.y !== null) {
                // Format amount as currency
                label += new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(context.parsed.y);
              }
              return label;
            }
          },
          titleColor: 'white', // Tooltip title color
          bodyColor: 'white',  // Tooltip body color
          backgroundColor: 'rgba(27, 27, 32, 0.8)' // Tooltip background, slightly transparent card color
        }
      },
      scales: {
        x: {
          grid: {
            display: false,
          },
          ticks: {
            color: 'white', /* Changed to white */
            font: {
              size: 10
            }
          }
        },
        y: {
          beginAtZero: true,
          grid: {
            color: '#2a2a31',
          },
          ticks: {
            color: 'white', /* Changed to white */
            font: {
              size: 10
            },
            callback: function(value) {
              return '£' + value.toFixed(0);
            }
          }
        }
      }
    }
  });
}


function updateAll() {
  renderYears(); // Render years first
  renderMonths(); // Then months for the active year
  applyRecurring(); // Ensure recurring expenses are applied *after* data migration and before totals are calculated
  updateViewModeText(); // Set the correct text for the current view mode and active year
  updateChart(); // Update chart based on current viewMode
  updateBalance(); // Balance is always for the activeMonth
  renderExpenses();
}

// Initial setup calls
migrateData(); // Run month format migration once on script load
normalizeExpenseData(); // Run data integrity check
updateLogosForAllExpenses(); // Apply logo rules to all existing data on load
updateAll(); // Initial rendering
</script>
</body>
</html>
