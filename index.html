<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Home Bill Tracker</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<style>
:root {
  --bg: #0e0e11;
  --card: #1b1b20;
  --text: #f5f5f7;
  --muted: #9a9aa0;
  --accent1: #0a84ff;
  --accent2: #ff375f;
  --danger: #ff453a;
  --user01-color: #0a84ff;
  --user02-color:   #d14d21;
  --radius: 18px;
}
* {
  box-sizing: border-box;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  /* Removed padding from body, moved to .container */
  display: flex; /* Flexbox for sticky footer */
  flex-direction: column; /* Flexbox for sticky footer */
  min-height: 100vh; /* Flexbox for sticky footer */
}
.container {
  max-width: 900px;
  margin: auto;
  padding: 0 20px; /* Added horizontal padding here */
  width: 100%; /* Ensure it takes full available width */
}
h1 {
  text-align: center;
  margin-top: 16px;
  margin-bottom: 6px;
}
.balance {
  text-align: center;
  color: var(--muted);
  margin-bottom: 16px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}
.balance .action-button {
  background: #2a2a31;
  color: var(--accent1);
  padding: 6px 16px;
  border-radius: 10px;
  font-weight: 500;
  font-size: 0.85rem;
  cursor: pointer;
  border: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  width: auto;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.balance .action-button:hover {
  background: #3a3a41;
}
.balance .action-button:active {
  opacity: 0.85;
}
.card {
  background: var(--card);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 16px;
}
.chart-wrapper {
  max-width: 520px;
  margin: 0 auto;
}
canvas {
  max-height: 160px;
}
.month-tabs, .year-tabs {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  justify-content: center;
  margin-bottom: 8px;
}
.year-tabs {
  margin-bottom: 0;
}
.year-month-separator {
  border-bottom: 1px solid #2a2a31;
  margin: 8px 0 16px 0;
}
.month-tab, .year-tab {
  padding: 8px 14px;
  border-radius: 14px;
  background: #2a2a31;
  font-size: 0.85rem;
  cursor: pointer;
  white-space: nowrap;
}
.month-tab.active, .year-tab.active {
  background: var(--accent1);
  font-weight: 600;
}
.view-switcher {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 15px;
  margin-top: 10px;
  margin-bottom: 10px;
  color: var(--muted);
  font-size: 0.9rem;
}
.view-switcher button {
  background: none;
  border: none;
  color: var(--muted);
  padding: 5px;
  cursor: pointer;
  font-size: 1.2rem;
  width: auto;
}
.view-switcher button:hover {
  color: var(--text);
}
.form {
  display: grid;
  grid-template-columns: 0.6fr 1.5fr 0.6fr 0.6fr auto;
  gap: 8px;
}
@media (max-width: 600px) {
  .form {
    grid-template-columns: 1fr;
  }
}
input, select {
  background: #2a2a31;
  border: none;
  border-radius: 14px;
  padding: 12px;
  color: var(--text);
  width: 100%;
}
button {
  border: none;
  border-radius: 14px;
  padding: 12px 18px;
  background: var(--accent1);
  color: white;
  font-weight: 600;
  cursor: pointer;
  width: 100%;
}
button:active {
  opacity: 0.85;
}
button.disabled, .action-button.disabled {
  background-color: #555 !important;
  cursor: not-allowed;
  opacity: 0.7;
}

button i, .action-button i {
  font-size: 1.2em;
}

.expense {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  padding: 10px 0;
  border-bottom: 1px solid #2a2a31;
}
.expense-left {
  display: flex;
  align-items: center;
  gap: 8px;
}
.logo {
  width: 20px;
  height: 20px;
  border-radius: 4px;
}
.expense-left .fa-receipt {
  font-size: 20px;
  width: 20px;
  text-align: center;
}
.actions {
  display: flex;
  gap: 10px;
  align-items: center;
}
.action {
  font-size: 0.8rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}
.action.delete {
  color: var(--danger);
}
.expand-chart-toggle i {
  transition: transform 0.2s ease-in-out;
}
.expand-chart-toggle.expanded i {
  transform: rotate(180deg);
}
.expense-chart-container {
  width: 100%;
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px dashed #2a2a31;
  max-width: 100%;
}
.expense-chart-container canvas {
  max-height: 120px;
  width: 100% !important;
  height: auto !important;
}
.recurring-indicator {
  color: var(--accent1);
  margin-left: 5px;
  font-size: 0.75rem;
}
.personal-indicator {
  color: var(--muted);
  margin-left: 5px;
  font-size: 0.85rem;
}
.profiles {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 24px;
  margin-top: 12px;
  margin-bottom: 16px;
}
.profile {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    border: 3px solid transparent;
    cursor: pointer;
    transition: border-color 0.25s ease;
}

.profile.active {
    border-color: var(--user01-color);
}

#user02Btn.active {
    border-color: var(--user02-color);
}
.export {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
}
.export button {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}
.note-input-wrapper {
  position: relative;
}
.suggestions-dropdown {
  position: absolute;
  top: calc(100% + 5px);
  left: 0;
  right: 0;
  background: var(--card);
  border-radius: 10px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  max-height: 120px;
  overflow-y: auto;
  z-index: 100;
  display: none;
  width: 100%;
}
.suggestions-dropdown div {
  padding: 8px 12px;
  cursor: pointer;
}
.suggestions-dropdown div:hover {
  background: #2a2a31;
}
.expense-header-content {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 8px;
  font-weight: 600;
}
.expense-header-info {
  display: flex;
  align-items: center;
  gap: 8px;
}
.expense-header-info .desktop-display {
  display: flex;
  align-items: center;
}
.expense-header-info .mobile-display {
  display: none;
  flex-direction: column;
  align-items: flex-start;
  line-height: 1.2;
}
.expense-header-info .mobile-display .person-name-line {
  margin-bottom: 2px;
}

.expense-header-actions {
  display: flex;
  gap: 8px;
}
.expense-header-actions .action-button.delete-selected {
  background-color: var(--danger);
  color: white;
}
.expense-header-avatar {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  object-fit: cover;
}
.expense-separator {
  border-bottom: 1px solid #2a2a31;
  margin-bottom: 10px;
}
input[type="checkbox"].expense-select-checkbox {
  appearance: none;
  background-color: #2a2a31;
  margin: 0;
  font: inherit;
  color: var(--text);
  width: 0.7em;
  height: 0.7em;
  border: 0.08em solid currentColor;
  border-radius: 0.08em;
  transform: translateY(-0.075em);
  display: grid;
  place-content: center;
  cursor: pointer;
  vertical-align: middle;
  margin-right: 6px;
}
input[type="checkbox"].expense-select-checkbox::before {
  content: "";
  width: 0.4em;
  height: 0.4em;
  transform: scale(0);
  transition: transform 120ms ease-in-out;
  box-shadow: inset 1em 1em var(--accent1);
  background-color: CanvasText;
  clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
}
input[type="checkbox"].expense-select-checkbox:checked::before {
  transform: scale(1);
}
input[type="checkbox"].expense-select-checkbox:focus {
  outline: max(2px, 0.15em) solid currentColor;
  outline-offset: max(2px, 0.15em);
}
.footer {
  margin-top: auto; /* Pushes the footer to the bottom */
  padding-bottom: 20px;
  text-align: center;
  font-size: 0.9em;
  color: var(--muted);
  line-height: 1;
}
.footer-link {
  color: var(--muted);
  text-decoration: none;
  display: inline-block;
  vertical-align: middle;
}
.footer-link:hover {
  color: var(--text);
}
.footer-link .footer-icon {
  font-size: 1.5em;
  padding: 0 5px;
  color: inherit;
}
.footer span {
  vertical-align: middle;
}
.action.delete.disabled,
.action.delete.disabled:hover {
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.6;
}
.action.delete.disabled:active {
  opacity: 0.6;
}

.form button .add-button-text {
  display: none;
}

/* Auth Inputs Layout */
.auth-inputs {
  display: flex;
  gap: 10px;
  margin-bottom: 16px;
}
.auth-inputs input {
  flex-grow: 1;
  width: auto; /* Important: Allows flex-grow to work */
  margin-bottom: 0; /* Clear any residual margin from previous inline styles */
}

/* Auth Container Centering */
#authContainer {
  text-align: center;
  max-width: 540px;
  margin: auto; /* Centers it horizontally and vertically within the flex body */
  z-index: 1000;
  width: 90%;
  box-sizing: border-box;
}

.auth-buttons {
  display: flex;
  gap: 10px;
  justify-content: center;
  margin-bottom: 16px;
}

.auth-buttons button {
  flex-grow: 1;
}

/* New Top Bar Container to hold the User Menu */
.top-bar-container {
  display: flex;
  align-items: center;
  justify-content: flex-start; /* Default to left for desktop */
  margin-top: 0;   /* Reset top margin */
  padding-top: 20px; /* Add top padding to match original vertical position */
  padding-left: 20px; /* Add left padding to match original horizontal position */
  padding-right: 20px; /* Add right padding */
  margin-bottom: 16px;
}

/* User Menu Styles */
#user-menu {
  z-index: 500;
  height: 48px;
  border-radius: var(--radius);
  overflow: hidden;
  background: var(--card);
  box-shadow: 0 4px 15px rgba(0,0,0,0.25);
  transition: width 0.4s ease;
  width: fit-content; /* Let it adapt to menu-content width */
  position: relative; /* Crucial for absolute positioning of toggle */
}

#userMenuToggle {
  display: block;
  cursor: pointer;
  opacity: 0;
  z-index: 999;
  margin: 0;
  width: 180px; /* Fixed width for clickable area (desktop and mobile) */
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
}

.menu-content {
  display: flex;
  align-items: center;
  height: 48px;
  width: 180px;          /* enough space for avatar + greeting + username */
  min-width: 180px;
  transition: width 0.4s ease;
  background: var(--card);
  color: var(--text);
}

/* Expanded state */
#userMenuToggle:checked ~ .menu-content {
  width: 220px;          /* extra ~70px for logout area */
}

.avatar {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  object-fit: cover;
  margin: 0 12px 0 8px;
  border: 2px solid rgba(255,255,255,0.2);
  flex-shrink: 0;
}

.user-info {
  flex: 1;
  min-width: 0;
  padding-right: 12px;
}

.greeting {
  font-size: 0.84rem;
  font-weight: 400;
  color: var(--muted);
  line-height: 1.1;
}

.username {
  font-size: 1.02rem;
  font-weight: 600;
  line-height: 1.2;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.logout-area {
  width: 0;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--danger);
  color: var(--text);
  overflow: hidden;
  transition: width 0.4s ease;
  flex-shrink: 0;
}

#userMenuToggle:checked ~ .menu-content .logout-area {
  width: 40px;           /* becomes visible only when expanded */
}

.logout-area:hover {
  background: var(--danger);
  opacity: 0.85; /* Add a slight opacity change on hover */
}

.logout-btn {
  width: 100%;
  height: 100%;
  background: transparent;
  border: none;
  color: inherit;
  font-size: 1rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0; /* Remove default button padding */
}

/* Optional: tiny avatar zoom on open */
#userMenuToggle:checked ~ .menu-content .avatar {
  transform: scale(1.06);
  transition: transform 0.5s ease;
}

@media (max-width: 600px) {
  .expense-header-info .desktop-display {
    display: none;
  }
  .expense-header-info .mobile-display {
    display: flex;
  }
  .expense-header-info .mobile-display .month-year-line {
    font-size: 0.85em;
  }
  .form button .add-button-text {
    display: inline;
    margin-left: 5px;
  }
  .auth-buttons button {
    flex-grow: 1;
  }
  .auth-inputs {
    flex-direction: column; /* Stack inputs vertically on mobile */
    gap: 8px; /* Adjust gap for stacked inputs */
  }

  /* Mobile: Center the user menu */
  .top-bar-container {
    justify-content: center; /* Center the menu horizontally */
    margin-top: 0;       /* Reset top margin for mobile */
    padding-top: 10px; /* Slightly less padding on mobile */
    padding-left: 10px;
    padding-right: 10px;
  }
  #user-menu {
    margin: 10px auto; /* Center itself within the flex container */
    height: 40px;
    border-radius: 20px;
  }
  .menu-content {
    height: 40px;
    width: 180px;
    min-width: 180px;
  }
  #userMenuToggle:checked ~ .menu-content {
    width: 240px; /* Expanded width for mobile */
  }
  .avatar {
    width: 30px;
    height: 30px;
    margin: 0 10px 0 6px;
  }
  .greeting {
    font-size: 0.75rem;
  }
  .username {
    font-size: 0.9rem;
  }
  .logout-area {
    width: 0;
  }
  #userMenuToggle:checked ~ .menu-content .logout-area {
    width: 60px; /* Logout area width for mobile */
  }
  .logout-btn {
    font-size: 1.1rem;
  }
  h1 {
    margin-top: 16px;
  }
}
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.month-tab.settled {
  background: #28a745;
  color: white;
  font-weight: 600;
}

.month-tab.unsettled-past-month {
  background: var(--danger);
  color: white;
  font-weight: 600;
  animation: blink 1.5s infinite ease-in-out;
}

</style>

</head>
<body>
<div id="appContentWrapper" class="container" style="display: none;">
  <div class="top-bar-container">
    <div id="user-menu">
      <input type="checkbox" id="userMenuToggle" />
      <div class="menu-content">
        <img id="userMenuAvatar" class="avatar" src="" alt="User Avatar">
        <div class="user-info">
          <div id="userMenuGreeting" class="greeting"></div>
          <div id="userMenuUsername" class="username"></div>
        </div>
        <div class="logout-area">
          <button class="logout-btn" onclick="handleLogout()">
            <i class="fa-solid fa-right-from-bracket"></i>
          </button>
        </div>
      </div>
    </div>
  </div>
  <!-- End New Top Bar Container -->

  <h1>Bills Overview</h1>
  <div class="balance" id="balanceText"></div>

  <div class="profiles">
    <img src="assets/person001.png" id="user01Btn" class="profile active" onclick="selectPerson('user01')">
    <img src="assets/person002.png" id="user02Btn" class="profile" onclick="selectPerson('user02')">
  </div>

  <div class="view-switcher">
    <button id="prevViewBtn" onclick="toggleViewMode()"><i class="fa-solid fa-chevron-left"></i></button>
    <span id="currentViewText">Monthly View</span>
    <button id="nextViewBtn" onclick="toggleViewMode()"><i class="fa-solid fa-chevron-right"></i></button>
  </div>
  <div class="card">
    <div class="chart-wrapper">
      <canvas id="billChart"></canvas>
    </div>
  </div>
  <div class="card">
    <div class="year-tabs" id="yearTabs"></div>
    <div class="year-month-separator"></div>
    <div class="month-tabs" id="monthTabs"></div>
  </div>
  <div class="card">
    <div class="form">
      <input id="amountInput" type="number" step="0.01" placeholder="£ amount">
      <div class="note-input-wrapper">
        <input id="noteInput" type="text" placeholder="Description or brand">
        <div id="suggestions" class="suggestions-dropdown"></div>
      </div>
      <select id="recurringInput">
        <option value="no">One-off</option>
        <option value="yes">Recurring</option>
      </select>
      <select id="sharedStatusInput">
        <option value="shared">Shared</option>
        <option value="personal">Personal</option>
      </select>
      <button onclick="addExpense()"><i class="fa-solid fa-circle-plus"></i> <span class="add-button-text">Add</span></button>
    </div>
  </div>
  <div class="card">
    <div id="expenseHeader"></div>
    <div id="expenseList"></div>
  </div>
</div>

<div class="card container" id="authContainer" style="display: none; text-align: center;">
    <h2>Login / Sign Up</h2>
    <div class="auth-inputs">
      <input type="email" id="authEmail" placeholder="Email">
      <input type="password" id="authPassword" placeholder="Password">
    </div>
    <div class="auth-buttons">
      <button onclick="handleAuth('signup')">Sign Up</button>
      <button onclick="handleAuth('login')">Login</button>
    </div>
    <p id="authMessage" style="color: var(--danger); margin-top: 10px;"></p>
</div>


<div class="footer">
<a href="https://www.linkedin.com/in/francisarcas/" target="_blank" class="footer-link" title="Francis Arcas LinkedIn">
<i class="fa-brands fa-linkedin footer-icon"></i>
</a>
<span style="margin: 0 10px;">|</span>
<a href="https://github.com/francisarcas/homebills" target="_blank" class="footer-link" title="Home Bills GitHub Repository">
<i class="fa-brands fa-github footer-icon"></i>
</a>
</div>

<script>
  let mySupabaseClient;
  let currentUser = null;
  let loggedInUserProfile = null;
  let householdProfilesMap = new Map(); // NEW: Store all household profiles
  let authContainer, authEmail, authPassword, authMessage;
  let appContentWrapper;

  // NEW User Menu elements
  let userMenu, userMenuToggle, userMenuAvatar, userMenuGreeting, userMenuUsername;

  const SUPABASE_URL = "https://qkbzkswjzzhrvqtssfxt.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFrYnprc3dqenpocnZxdHNzZnh0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk3MTIzNzAsImV4cCI6MjA4NTI4ODM3MH0.BiDcAO2TDdIMIi888Uq7NQE7Bj-ZnjwI7sDMu6Erk6g";

  try {
    mySupabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  } catch (e) {
    console.error("Failed to initialize Supabase client. Is the Supabase CDN script loaded correctly and defining 'supabase' (lowercase)?", e);
    alert("Error: Supabase library failed to load. Please check your internet connection, browser console for network errors, or try disabling ad-blockers.");
  }

  const MONTHS = ["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];
  const SUGGESTION_BRANDS = [
    "amex", "affinity water", "amazon", "b&q", "barclays", "british airways", "costco", "council tax", "eurostar",
    "hotel", "hsbc", "hyperoptic", "iberia", "insite energy", "itsu", "john lewis", "klarna", "lidl", "lottery", "lner", "m&s", "morrisons", "mortgage", "netflix",
    "octopus energy", "play station", "prime", "renfe", "revolut", "rent", "ryanair", "sainsbury's", "strava", "tfl", "tk.max", "accommodation", "third space"
  ].sort();
  const BRAND_LOGO_RULES = [
    { keywords: ["affinity water"], logo: "assets/logos/affinitywater.png" },
    { keywords: ["amex"], logo: "assets/logos/amex.png" },
    { keywords: ["amazon"], logo: "assets/logos/amazon.png" },
    { keywords: ["b&q"], logo: "assets/logos/bandq.png" },
    { keywords: ["barclays"], logo: "assets/logos/barclays.png" },
    { keywords: ["british airways"], logo: "assets/logos/britishairways.png" },
    { keywords: ["costco"], logo: "assets/logos/costco.png" },
    { keywords: ["hyperoptic"], logo: "assets/logos/hyperoptic.png" },
    { keywords: ["hsbc"], logo: "assets/logos/hsbc.png" },
    { keywords: ["iberia"], logo: "assets/logos/iberia.png" },
    { keywords: ["insite energy"], logo: "assets/logos/insiteenergy.png" },
    { keywords: ["itsu"], logo: "assets/logos/itsu.png" },
    { keywords: ["john lewis"], logo: "assets/logos/johnlewis.png" },
    { keywords: ["klarna"], logo: "assets/logos/klarna.png" },
    { keywords: ["lottery"], logo: "assets/logos/lottery.png" },
    { keywords: ["lidl"], logo: "assets/logos/lidl.png" },
    { keywords: ["lner"], logo: "assets/logos/lner.png" },
    { keywords: ["m&s"], logo: "assets/logos/mands.png" },
    { keywords: ["morrisons"], logo: "assets/logos/morrisons.png" },
    { keywords: ["mortgage"], logo: "assets/logos/mortgage.png" },
    { keywords: ["netflix"], logo: "assets/logos/netflix.png" },
    { keywords: ["octopus energy"], logo: "assets/logos/octopusenergy.png" },
    { keywords: ["play station"], logo: "assets/logos/playstation.png" },
    { keywords: ["prime"], logo: "assets/logos/prime.png" },
    { keywords: ["renfe"], logo: "assets/logos/renfe.png" },
    { keywords: ["revolut"], logo: "assets/logos/revolut.png" },
    { keywords: ["rent"], logo: "assets/logos/rent.png" },
    { keywords: ["ryanair"], logo: "assets/logos/ryanair.png" },
    { keywords: ["sainsbury's"], logo: "assets/logos/sainsburys.png" },
    { keywords: ["strava"], logo: "assets/logos/strava.png" },
    { keywords: ["tfl"], logo: "assets/logos/tfl.png" },
    { keywords: ["tk.max"], logo: "assets/logos/tkmax.png" },
    { keywords: ["eurostar"], logo: "assets/logos/eurostar.png" },
    { keywords: ["council tax", "council-tax", "brent council", "brent"], logo: "assets/logos/brent.png" },
    { keywords: ["hotel", "accommodation", "booking.com"], logo: "assets/logos/booking.png" },
    { keywords: ["third space"], logo: "assets/logos/thirdspace.png" }
  ];

  const today = new Date();
  let activeYear = today.getFullYear();
  let activeMonth = `${activeYear}-${MONTHS[today.getMonth()]}`;
  let activePerson = "user01";
  let viewMode = 'monthly';
  const data = {
    user01: [],
    user02: [],
    settlements: JSON.parse(localStorage.getItem("billSettlements")) || {}
  };
  if (!data.settlements) { data.settlements = {}; }

  let editMode = false;
  let selectedExpenses = [];
  const expenseChartInstances = {};

  let noteInput, suggestionsDiv, yearTabsDiv, expenseHeaderDiv, balanceTextDiv,
    currentViewTextSpan, sharedStatusInput, amountInput, recurringInput, expenseListDiv,
    user01Btn, user02Btn;
    // Removed old logoutButton, greetingText, userAvatar from global scope as they are replaced

function getGreeting(userName) {
    const hour = new Date().getHours();
    let greetingPhrase;

    if (hour >= 6 && hour < 12) {
        greetingPhrase = "Good morning";
    } else if (hour >= 12 && hour < 18) {
        greetingPhrase = "Good afternoon";
    } else if (hour >= 18 && hour < 24) {
        greetingPhrase = "Good evening";
    } else {
        greetingPhrase = "Good night";
    }
    return `${greetingPhrase},`; // Adjusted to fit into the two lines
}

async function handleAuth(type) {
    authMessage.textContent = '';
    const email = authEmail.value;
    const password = authPassword.value;

    if (!email || !password) {
        authMessage.textContent = 'Please enter both email and password.';
        return;
    }

    let response;
    if (type === 'signup') {
        authMessage.textContent = 'Signing up... Please wait.';
        response = await mySupabaseClient.auth.signUp({ email, password });
    } else {
        authMessage.textContent = 'Logging in...';
        response = await mySupabaseClient.auth.signInWithPassword({ email, password });
    }

    if (response.error) {
        authMessage.textContent = response.error.message;
        console.error("Auth error:", response.error);
    } else {
        if (type === 'signup' && !response.data.user?.identities?.length) {
            authMessage.textContent = 'Sign up successful! Please check your email for confirmation to log in.';
        } else {
            authMessage.textContent = 'Login successful!';
            authEmail.value = '';
            authPassword.value = '';
            currentUser = response.data.user;

            const { data: profileData, error: profileError } = await mySupabaseClient
                .from('profiles')
                .select('*')
                .eq('user_id', currentUser.id)
                .single();

            if (profileError) {
                console.error("Error fetching user profile after auth:", profileError);
                await mySupabaseClient.auth.signOut();
                currentUser = null;
                loggedInUserProfile = null;
                authMessage.textContent = 'Login failed: Could not retrieve user profile. Please ensure you have a profile entry.';
                updateAuthUI();
            } else {
                loggedInUserProfile = profileData;
                updateAuthUI();
                await updateAll();
            }
        }
    }
}


async function handleLogout() {
    const { error } = await mySupabaseClient.auth.signOut();
    if (error) {
        console.error("Logout error:", error);
        alert("Error logging out: " + error.message);
    } else {
        currentUser = null;
        loggedInUserProfile = null;
        householdProfilesMap.clear(); // Clear household profiles on logout
        data.user01 = [];
        data.user02 = [];
        data.settlements = {};
        localStorage.removeItem("billSettlements");
        updateAuthUI();
        updateAll();
        alert("Logged out successfully!");
    }
}

function updateAuthUI() {
    const profilesDiv = document.querySelector('.profiles');

    if (currentUser && loggedInUserProfile) {
        authContainer.style.display = 'none';
        appContentWrapper.style.display = 'block';
        profilesDiv.style.display = 'flex';
        userMenu.style.display = 'block'; // Show the new user menu

        const personName = loggedInUserProfile.display_name || currentUser.email.split('@')[0]; // Fallback to email prefix
        const personKey = loggedInUserProfile.role;
        const avatarSrc = loggedInUserProfile.avatar_url || (personKey === 'user01' ? "assets/person001.png" : "assets/person002.png"); // Fallback avatar

        selectPerson(personKey); // Initialize active person

        userMenuAvatar.src = avatarSrc;
        userMenuGreeting.textContent = getGreeting(personName);
        userMenuUsername.textContent = personName;
        userMenuToggle.checked = false; // Ensure menu is closed on login/refresh

    } else {
        authContainer.style.display = 'block';
        appContentWrapper.style.display = 'none';
        profilesDiv.style.display = 'none';
        userMenu.style.display = 'none'; // Hide the new user menu

        userMenuAvatar.src = "";
        userMenuGreeting.textContent = "";
        userMenuUsername.textContent = "";
        userMenuToggle.checked = false; // Ensure menu is closed
    }
}

  function initializeDOMElements() {
    noteInput = document.getElementById('noteInput');
    suggestionsDiv = document.getElementById('suggestions');
    yearTabsDiv = document.getElementById('yearTabs');
    expenseHeaderDiv = document.getElementById('expenseHeader');
    balanceTextDiv = document.getElementById('balanceText');
    currentViewTextSpan = document.getElementById('currentViewText');
    sharedStatusInput = document.getElementById('sharedStatusInput');
    amountInput = document.getElementById('amountInput');
    recurringInput = document.getElementById('recurringInput');
    expenseListDiv = document.getElementById('expenseList');
    authContainer = document.getElementById('authContainer');
    authEmail = document.getElementById('authEmail');
    authPassword = document.getElementById('authPassword');
    authMessage = document.getElementById('authMessage');
    user01Btn = document.getElementById('user01Btn');
    user02Btn = document.getElementById('user02Btn');
    appContentWrapper = document.getElementById('appContentWrapper');

    // NEW User Menu elements
    userMenu = document.getElementById('user-menu');
    userMenuToggle = document.getElementById('userMenuToggle');
    userMenuAvatar = document.getElementById('userMenuAvatar');
    userMenuGreeting = document.getElementById('userMenuGreeting');
    userMenuUsername = document.getElementById('userMenuUsername');
  }

  function generateUUID() {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  function getMonthNum(monthKey) {
    const year = parseInt(monthKey.substring(0, 4));
    const monthAbbr = monthKey.substring(5, 8);
    const monthIdx = MONTHS.indexOf(monthAbbr);
    if (monthIdx === -1) throw new Error(`Invalid month abbreviation: ${monthAbbr}`);
    return year * 12 + monthIdx;
  }

  function showSuggestions() {
    if (!noteInput || !suggestionsDiv) return;
    const inputValue = noteInput.value.toLowerCase();
    suggestionsDiv.innerHTML = '';
    if (inputValue.length === 0 && document.activeElement !== noteInput) {
      suggestionsDiv.style.display = 'none';
      return;
    }
    const matchingBrands = SUGGESTION_BRANDS.filter(brandItem =>
      brandItem.includes(inputValue)
    );
    if (matchingBrands.length > 0) {
      matchingBrands.forEach(brandItem => {
        const suggestionItem = document.createElement('div');
        let displayText = brandItem.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        // FIX: Corrected `brandName` to `brandItem` for special capitalization
        if (brandItem === "m&s") displayText = "M&S";
        if (brandItem === "b&q") displayText = "B&Q";
        if (brandItem === "hsbc") displayText = "HSBC";
        if (brandItem === "lner") displayText = "LNER";
        if (brandItem === "tfl") displayText = "TFL";
        if (brandItem === "amex") displayText = "AMEX";
        if (brandItem === "tk.max") displayText = "TK.MAX";
        suggestionItem.textContent = displayText;
        suggestionItem.onmousedown = (event) => {
          event.preventDefault();
          selectSuggestion(brandItem);
        };
        suggestionsDiv.appendChild(suggestionItem);
      });
      suggestionsDiv.style.display = 'block';
    } else {
      suggestionsDiv.style.display = 'none';
    }
  }
  function selectSuggestion(brandName) {
    if (!noteInput || !suggestionsDiv) return;
    let capitalizedBrand = brandName.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
    if (brandName === "m&s") capitalizedBrand = "M&S";
    if (brandName === "b&q") capitalizedBrand = "B&Q";
    if (brandName === "hsbc") capitalizedBrand = "HSBC";
    if (brandName === "lner") capitalizedBrand = "LNER";
    if (brandName === "tfl") capitalizedBrand = "TFL";
    if (brandName === "amex") capitalizedBrand = "AMEX";
    if (brandName === "tk.max") capitalizedBrand = "TK.MAX";
    noteInput.value = capitalizedBrand;
    suggestionsDiv.style.display = 'none';
  }
  function hideSuggestions() {
    if (!noteInput || !suggestionsDiv) return;
    setTimeout(() => {
      if (document.activeElement !== noteInput && !suggestionsDiv.contains(document.activeElement)) {
        suggestionsDiv.style.display = 'none';
      }
    }, 100);
  }

  function normalizeMonthKey(monthKey) {
    if (monthKey && monthKey.match(/^\d{4}-\d{2}$/)) {
      const [year, monthNum] = monthKey.split('-');
      const monthIndex = parseInt(monthNum, 10) - 1;
      if (monthIndex >= 0 && monthIndex < 12) {
        return `${year}-${MONTHS[monthIndex]}`;
      }
    }
    return monthKey;
  }

  function save() {
    localStorage.setItem("billSettlements", JSON.stringify(data.settlements));
  }

  function capitalise(name) {
    return name.charAt(0).toUpperCase() + name.slice(1);
  }
  function detectLogo(note) {
    const lowerCaseNote = note.toLowerCase();
    for (const rule of BRAND_LOGO_RULES) {
      for (const keyword of rule.keywords) {
        if (lowerCaseNote.includes(keyword)) {
          return rule.logo;
        }
      }
    }
    return null;
  }
  function updateLogosForAllExpenses() {
    let changed = false;
    ["user01", "user02"].forEach(p => {
      data[p].forEach(e => {
        const newLogo = detectLogo(e.note);
        if (e.logo !== newLogo) {
          e.logo = newLogo;
          changed = true;
        }
      });
    });
    if (changed) {
      save();
    }
  }
  function getYears() {
    const years = new Set();
    years.add(new Date().getFullYear().toString());
    ["user01", "user02"].forEach(p => {
      data[p].forEach(e => {
        if (e.month) {
          years.add(e.month.substring(0, 4));
        }
      });
    });
    return [...years].sort((a, b) => parseInt(a) - parseInt(b));
  }
  function renderYears() {
    if (!yearTabsDiv) return;
    yearTabsDiv.innerHTML = "";
    getYears().forEach(year => {
      const tab = document.createElement("div");
      tab.className = "year-tab" + (year === activeYear.toString() ? " active" : "");
      tab.textContent = year;
      tab.onclick = () => {
        activeYear = parseInt(year);
        const currentMonthAbbr = activeMonth.substring(5, 8);
        activeMonth = `${activeYear}-${currentMonthAbbr}`;
        updateAll();
      };
      yearTabsDiv.appendChild(tab);
    });
  }
 function renderMonths() {
  const monthTabsElement = document.getElementById('monthTabs');
  if (!monthTabsElement) return;

  monthTabsElement.innerHTML = "";

  const currentYear = new Date().getFullYear();
  const currentMonthIndex = new Date().getMonth();

  MONTHS.forEach((m, index) => {
    const tab = document.createElement("div");
    const monthKey = `${activeYear}-${m}`;

    tab.className = "month-tab";
    if (monthKey === activeMonth) {
      tab.classList.add("active");
    }

    const isSettled = data.settlements[monthKey] === true;

    const isPastMonth = (activeYear < currentYear) ||
                        (activeYear === currentYear && index < currentMonthIndex);

    if (isSettled) {
      tab.classList.add("settled");
    } else if (isPastMonth) {
      tab.classList.add("unsettled-past-month");
    }

    tab.textContent = m;
    tab.onclick = () => {
      activeMonth = monthKey;
      updateAll();
    };
    monthTabsElement.appendChild(tab);
  });

  const activeMonthTab = monthTabsElement.querySelector('.month-tab.active');
  if (activeMonthTab) {
    requestAnimationFrame(() => {
      activeMonthTab.scrollIntoView({
        behavior: 'smooth',
        inline: 'center',
        block: 'nearest'
      });
    });
  }
}

  function markMonthAsSettled(status) {
    data.settlements[activeMonth] = status;
    save();
    updateAll();
  }
  function getMonthlyExpenses(personKey, monthKey) {
    const expenses = data[personKey].filter(e => normalizeMonthKey(e.month) === monthKey);
    const shared = expenses.filter(e => !e.isPersonal).reduce((sum, e) => sum + e.amount, 0);
    const personal = expenses.filter(e => e.isPersonal).reduce((sum, e) => sum + e.amount, 0);
    return { shared, personal };
  }
  function calculateAnnualTotals() {
    const annualTotals = {
      user01: { shared: 0, personal: 0 }
    };
    if (data.user02) {
      annualTotals.user02 = { shared: 0, personal: 0 };
    }
    const yearPrefix = activeYear.toString();
    ["user01", "user02"].forEach(personKey => {
      if (!data[personKey]) return;
      const actualPersonExpenses = data[personKey].filter(e => !e.isProjected);
      const latestRecurringSharedAmounts = {};
      const latestRecurringPersonalAmounts = {};
      const firstRecurringSharedMonth = {};
      const firstRecurringPersonalMonth = {};
      actualPersonExpenses.filter(e => e.recurring).forEach(e => {
        const key = e.note.toLowerCase();
        const currentFirstMonth = e.isPersonal ? firstRecurringPersonalMonth[key] : firstRecurringSharedMonth[key];
        if (!currentFirstMonth || getMonthNum(e.month) < getMonthNum(currentFirstMonth)) {
          if (e.isPersonal) firstRecurringPersonalMonth[key] = e.month;
          else firstRecurringSharedMonth[key] = e.month;
        }
        const currentLatestAmount = e.isPersonal ? latestRecurringPersonalAmounts[key] : latestRecurringSharedAmounts[key];
        if (!currentLatestAmount || getMonthNum(e.month) > getMonthNum(currentLatestAmount.month)) {
          if (e.isPersonal) latestRecurringPersonalAmounts[key] = { amount: e.amount, month: e.month };
          else latestRecurringSharedAmounts[key] = { amount: e.amount, month: e.month };
        }
      });
      for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
        const monthOfYear = MONTHS[monthIndex];
        const currentYearMonthKey = `${yearPrefix}-${monthOfYear}`;
        let monthlySharedTotal = 0;
        let monthlyPersonalTotal = 0;
        const expensesForThisMonth = data[personKey].filter(e => e.month === currentYearMonthKey);
        expensesForThisMonth.forEach(e => {
          if (e.isPersonal) {
            monthlyPersonalTotal += e.amount;
          } else {
            monthlySharedTotal += e.amount;
          }
        });
        annualTotals[personKey].shared += monthlySharedTotal;
        annualTotals[personKey].personal += monthlyPersonalTotal;
      }
    });
    return annualTotals;
  }
  function updateBalance() {
    if (!balanceTextDiv) return;

    const user01Profile = householdProfilesMap.get('user01');
    const user02Profile = householdProfilesMap.get('user02');
    const user01DisplayName = user01Profile ? user01Profile.display_name : 'User 1';
    const user02DisplayName = user02Profile ? user02Profile.display_name : 'User 2';


    const user01Monthly = getMonthlyExpenses("user01", activeMonth);
    const user02Monthly = getMonthlyExpenses("user02", activeMonth);
    const a = user01Monthly.shared;
    const b = user02Monthly.shared;
    const diff = Math.abs(a - b) / 2;
    let balanceMessage = "";
    let actionButton = "";
    const isSettled = data.settlements[activeMonth];
    if (isSettled) {
      balanceMessage = `All settled for ${activeMonth}!`;
      actionButton = `<button class="action-button" onclick="markMonthAsSettled(false)"><i class="fa-solid fa-undo"></i> Unmark as Settled</button>`;
    } else {
      if (a === b) {
        balanceMessage = "All settled";
      } else if (a > b) {
        balanceMessage = `${user02DisplayName} owes ${user01DisplayName} £${diff.toFixed(2)}`;
        actionButton = `<button class="action-button" onclick="markMonthAsSettled(true)"><i class="fa-solid fa-check"></i> Mark as Settled</button>`;
      } else {
        balanceMessage = `${user01DisplayName} owes ${user02DisplayName} £${diff.toFixed(2)}`;
        actionButton = `<button class="action-button" onclick="markMonthAsSettled(true)"><i class="fa-solid fa-check"></i> Mark as Settled</button>`;
      }
    }
    balanceTextDiv.innerHTML = `
      <span>${balanceMessage}</span>
      ${actionButton}
    `;
  }
  function renderExpenseHeader() {
    if (!expenseHeaderDiv) return;

    const activePersonProfile = householdProfilesMap.get(activePerson);
    const activePersonDisplayName = activePersonProfile ? activePersonProfile.display_name : capitalise(activePerson);
    const avatarImgSrc = activePersonProfile ? activePersonProfile.avatar_url : (activePerson === "user01" ? "assets/person001.png" : "assets/person002.png");


    let actionButtonsHtml = '';
    if (!editMode) {
      actionButtonsHtml = `<button class="action-button" onclick="toggleEditMode()"><i class="fa-solid fa-pen-to-square"></i> Edit</button>`;
    } else {
      const expensesForMonth = data[activePerson].filter(e => normalizeMonthKey(e.month) === activeMonth);
      const allSelected = expensesForMonth.length > 0 && expensesForMonth.every(e => selectedExpenses.includes(e.uuid));
      const deleteButtonDisabled = selectedExpenses.length === 0 ? 'disabled' : '';
      actionButtonsHtml = `
        <button class="action-button" onclick="cancelEditMode()" title="Cancel Edit"><i class="fa-solid fa-xmark"></i></button>
        <button class="action-button" onclick="toggleSelectAll()" title="${allSelected ? 'Deselect All' : 'Select All'}"><i class="fa-regular fa-square-check"></i></button>
        <button class="action-button delete-selected ${deleteButtonDisabled}" onclick="confirmDeleteSelected()" ${deleteButtonDisabled} title="Delete Selected Expenses"><i class="fa-solid fa-trash"></i></button>
      `;
    }

    expenseHeaderDiv.innerHTML = `
      <div class="expense-header-content">
        <div class="expense-header-info">
          <img src="${avatarImgSrc}" class="expense-header-avatar">
          <div class="desktop-display">
            <span>${activePersonDisplayName} – ${activeMonth}</span>
          </div>
          <div class="mobile-display">
            <span class="person-name-line">${activePersonDisplayName}</span>
            <span class="month-year-line">${activeMonth}</span>
          </div>
        </div>
        <div class="expense-header-actions">
          ${actionButtonsHtml}
        </div>
      </div>
      <div class="expense-separator"></div>
    `;
  }
  function getExpenseByUUID(uuid) {
    return data[activePerson].find(e => e.uuid === uuid);
  }
  function getExpenseIndexByUUID(uuid) {
    return data[activePerson].findIndex(e => e.uuid === uuid);
  }
  function renderExpenses() {
    if (!expenseListDiv) return;
    for (const uuid in expenseChartInstances) {
      if (expenseChartInstances.hasOwnProperty(uuid)) {
        expenseChartInstances[uuid].destroy();
      }
    }
    Object.keys(expenseChartInstances).forEach(key => delete expenseChartInstances[key]);
    expenseListDiv.innerHTML = "";
    const expensesForMonth = data[activePerson]
      .filter(e => normalizeMonthKey(e.month) === activeMonth)
      .sort((a, b) => {
        if (a.isProjected && !b.isProjected) return 1;
        if (!a.isProjected && b.isProjected) return -1;
        if (a.amount < b.amount) return 1;
        if (a.amount > b.amount) return -1;
        return a.note.localeCompare(b.note);
      });
    expensesForMonth.forEach((e) => {
      const expenseUuid = e.uuid;
      const row = document.createElement("div");
      row.className = "expense";
      const iconContent = e.logo ? `<img class="logo" src="${e.logo}" onerror="this.remove()">` : `<i class="fa-solid fa-receipt"></i>`;
      const recurringIndicator = e.recurring ? `<i class="fa-solid fa-repeat recurring-indicator" title="Recurring expense"></i>` : '';
      const personalIndicator = e.isPersonal ? `<i class="fa-solid fa-user personal-indicator" title="Personal expense (not shared)"></i>` : '';
      const projectedIndicator = e.isProjected ? `<i class="fa-solid fa-clock recurring-indicator" title="This is a forecast based on your recurring bill – not yet paid"></i>` : '';
      let actionsHtml = '';
      let checkboxHtml = '';
      if (editMode) {
        const isChecked = selectedExpenses.includes(expenseUuid) ? 'checked' : '';
        checkboxHtml = `<input type="checkbox" class="expense-select-checkbox" ${isChecked} onchange="toggleExpenseSelection(this, '${expenseUuid}')">`;
      } else {
        actionsHtml = `
          ${personalIndicator}
          ${projectedIndicator}
          <span class="action expand-chart-toggle" data-uuid="${expenseUuid}" onclick="toggleExpenseChart(this, '${expenseUuid}')"><i class="fa-solid fa-chevron-down"></i></span>
          <span class="action" onclick="editExpenseByUUID('${expenseUuid}')"><i class="fa-solid fa-pencil"></i></span>
          <span class="action delete ${e.isProjected ? 'disabled' : ''}"
                onclick="${e.isProjected ? '' : `deleteExpenseByUUID('${expenseUuid}')`}">
            <i class="fa-solid fa-trash"></i>
          </span>
        `;
      }
      row.innerHTML = `
        <div class="expense-left">
          ${iconContent}
          <div>${e.note} ${recurringIndicator}<br><small>£${e.amount.toFixed(2)}</small></div>
        </div>
        <div class="actions">
          ${checkboxHtml}
          ${actionsHtml}
        </div>
        <div id="expenseChartWrapper_${expenseUuid}" class="expense-chart-container" style="display:none;">
          <canvas id="expenseChartCanvas_${expenseUuid}></canvas>
        </div>
      `;
      expenseListDiv.appendChild(row);
    });
  }
  async function addExpense() {
    if (!amountInput || !noteInput || !recurringInput || !sharedStatusInput) {
      console.error("DOM elements not initialized for addExpense. This should not happen if initApp() ran correctly.");
      alert("Application not fully loaded. Please refresh the page.");
      return;
    }

    const amount = parseFloat(amountInput.value);
    const note = noteInput.value.trim();
    const isRecurring = recurringInput.value === "yes";
    const isPersonal = sharedStatusInput.value === "personal";

    if (!amount || !note) {
      alert("Please enter both amount and description");
      return;
    }
    if (amount <= 0) {
      alert("Amount must be greater than zero");
      return;
    }
    if (amount > 999999) {
      alert("Amount seems too large. Please check.");
      return;
    }

    const newExpenseForSupabase = {
      month: activeMonth,
      amount: amount,
      note: note,
      logo: detectLogo(note),
      recurring: isRecurring,
      isPersonal: isPersonal,
      isProjected: false,
      person: activePerson,
    };

    const { data: insertedData, error } = await mySupabaseClient
      .from('expenses')
      .insert([newExpenseForSupabase])
      .select();

    if (error) {
      console.error("Error adding expense to Supabase:", error);
      alert("Error adding expense. Please check the console.");
      return;
    }

    amountInput.value = "";
    noteInput.value = "";
    recurringInput.value = "no";
    sharedStatusInput.value = "shared";
    suggestionsDiv.style.display = 'none';

    updateAll();
  }

  async function editExpenseByUUID(uuid) {
  if (editMode) {
    cancelEditMode();
    setTimeout(() => editExpenseByUUID(uuid), 100);
    return;
  }
  const expense = getExpenseByUUID(uuid);
  if (!expense) {
    console.error("Expense not found for editing with UUID:", uuid);
    return;
  }
  if (expense.isProjected) {
    alert("Projected expenses cannot be edited directly. Please edit an actual entry for this recurring series.");
    return;
  }

  const newNote = prompt("Description", expense.note);
  if (newNote === null) return;
  const newAmountStr = prompt("Amount", expense.amount);
  if (newAmountStr === null) return;

  if (!newNote.trim() || !newAmountStr.trim()) {
    alert("Description and Amount cannot be empty.");
    return;
  }
  const newAmount = parseFloat(newAmountStr);
  if (isNaN(newAmount) || newAmount <= 0) {
    alert("Please enter a valid amount greater than zero");
    return;
  }
  if (newAmount > 999999) {
    alert("Amount seems too large. Please check.");
    return;
  }

  const originalAmount = expense.amount;
  const originalNote = expense.note;
  let dataChanged = false;

  const updatedFields = {
    note: newNote.trim(),
    amount: newAmount,
    logo: detectLogo(newNote.trim())
  };

  if (expense.recurring && newNote.trim().toLowerCase() !== originalNote.toLowerCase()) {
    if (confirm("You changed the description for a recurring expense. Do you want to update the description for all occurrences of this series?")) {
      const { error: updateSeriesError } = await mySupabaseClient
        .from('expenses')
        .update({ note: newNote.trim(), logo: detectLogo(newNote.trim()) })
        .eq('note', originalNote)
        .eq('isPersonal', expense.isPersonal)
        .eq('recurring', true)
        .eq('person', activePerson);

      if (updateSeriesError) {
        console.error("Error updating recurring series description:", updateSeriesError);
        alert("Error updating recurring series description. Please check console.");
        return;
      }
      dataChanged = true;
    }
  }

  if (expense.recurring && newAmount !== originalAmount) {
    if (confirm("Do you want to update all future occurrences of this recurring expense to the new amount?")) {
      const { error: updateFutureError } = await mySupabaseClient
        .from('expenses')
        .update({ amount: newAmount })
        .eq('note', updatedFields.note)
        .eq('isPersonal', expense.isPersonal)
        .eq('recurring', true)
        .gte('month', expense.month)
        .eq('person', activePerson);

      if (updateFutureError) {
        console.error("Error updating future recurring amounts:", updateFutureError);
        alert("Error updating future recurring amounts. Please check console.");
        return;
      }
      dataChanged = true;
    }
  }

  const { error: updateError } = await mySupabaseClient
    .from('expenses')
    .update(updatedFields)
    .eq('id', uuid)
    .eq('person', activePerson);

  if (updateError) {
    console.error("Error updating expense in Supabase:", updateError);
    alert("Error updating expense. Please check the console.");
    return;
  }

  updateAll();
}

  async function deleteExpenseByUUID(uuid) {
    if (editMode) {
      cancelEditMode();
      setTimeout(() => deleteExpenseByUUID(uuid), 100);
      return;
    }
    const expenseToDelete = getExpenseByUUID(uuid);
    if (!expenseToDelete) {
      console.error("Expense not found for deletion with UUID:", uuid);
      return;
    }
    if (expenseToDelete.isProjected) {
      alert("Projected expenses cannot be deleted directly. Please delete an actual entry for this recurring series to stop its projection.");
      return;
    }

    let confirmMessage = "Delete expense?";
    if (expenseToDelete.recurring) {
      if (confirm("This is a recurring expense. Do you want to delete ONLY this specific occurrence? (Click 'Cancel' to be asked about deleting the series)")) {
        const { error } = await mySupabaseClient
          .from('expenses')
          .delete()
          .eq('id', uuid)
          .eq('person', activePerson);

        if (error) {
          console.error("Error deleting expense from Supabase:", error);
          alert("Error deleting expense. Please check the console.");
          return;
        }
        updateAll();
        return;
      } else {
        if (!confirm("Okay, do you want to delete this expense AND ALL FUTURE recurring instances of this series?")) {
          return;
        }
      }
      const { error } = await mySupabaseClient
        .from('expenses')
        .delete()
        .eq('note', expenseToDelete.note)
        .eq('isPersonal', expenseToDelete.isPersonal)
        .gte('month', expenseToDelete.month)
        .eq('person', activePerson);

      if (error) {
        console.error("Error deleting recurring series from Supabase:", error);
        alert("Error deleting recurring series. Please check the console.");
        return;
      }
      updateAll();
      return;
    }

    if (!confirm(confirmMessage)) return;

    const { error: singleDeleteError } = await mySupabaseClient
      .from('expenses')
      .delete()
      .eq('id', uuid)
      .eq('person', activePerson);

    if (singleDeleteError) {
      console.error("Error deleting expense from Supabase:", singleDeleteError);
      alert("Error deleting expense. Please check the console.");
      return;
    }
    updateAll();
  }

  function selectPerson(p) {
    activePerson = p;
    const user01Btn = document.getElementById('user01Btn');
    const user02Btn = document.getElementById('user02Btn');

    if (user01Btn) {
        user01Btn.classList.toggle("active", p === 'user01');
        user01Btn.style.borderColor = (p === 'user01') ? 'var(--user01-color)' : 'transparent';
    }
    if (user02Btn) {
        user02Btn.classList.toggle("active", p === 'user02');
        user02Btn.style.borderColor = (p === 'user02') ? 'var(--user02-color)' : 'transparent';
    }
    
    // Ensure the other button is not active and its border is transparent
    if (p === 'user01' && user02Btn) {
        user02Btn.classList.remove('active');
        user02Btn.style.borderColor = 'transparent';
    } else if (p === 'user02' && user01Btn) {
        user01Btn.classList.remove('active');
        user01Btn.style.borderColor = 'transparent';
    }

    cancelEditMode();
    updateAll();
  }
  const chart = new Chart(document.getElementById("billChart"), {
    type: "bar",
    data: {
      labels: ["user01", "user02"],
      datasets: []
    },
    options: {
      indexAxis: "y",
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          mode: 'index',
          intersect: false,
          callbacks: {
            label: function(context) {
              let label = context.dataset.label || '';
              if (label) {
                label += ': ';
              }
              if (context.parsed.x !== null) {
                label += new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(context.parsed.x);
              }
              return label;
            },
            footer: function(tooltipItems) {
              let total = 0;
              tooltipItems.forEach(function(tooltipItem) {
                total += tooltipItem.parsed.x;
              });
              return 'Total: ' + new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(total);
            }
          },
          titleColor: 'white',
          bodyColor: 'white',
          backgroundColor: 'rgba(27, 27, 32, 0.8)'
        }
      },
      scales: {
        x: {
          stacked: true,
          ticks: { color: "#f5f5f7" },
          grid: { color: "#2a2a31" }
        },
        y: {
          stacked: true,
          ticks: { color: "#f5f5f7" },
          grid: { display: false }
        }
      },
      elements: {
        bar: {
          borderRadius: 0
        }
      }
    }
  });
  function updateChart() {
    const user01DisplayName = householdProfilesMap.get('user01')?.display_name || 'User 1';
    const user02DisplayName = householdProfilesMap.get('user02')?.display_name || 'User 2';

    let user01Shared, user01Personal, user02Shared, user02Personal;
    if (viewMode === 'monthly') {
      const user01Monthly = getMonthlyExpenses("user01", activeMonth);
      const user02Monthly = getMonthlyExpenses("user02", activeMonth);
      user01Shared = user01Monthly.shared;
      user01Personal = user01Monthly.personal; // Corrected: this should be user01's personal expenses
      user02Shared = user02Monthly.shared;
      user02Personal = user02Monthly.personal;
    } else {
      const annualTotals = calculateAnnualTotals();
      user01Shared = annualTotals.user01.shared;
      user01Personal = annualTotals.user01.personal;
      user02Shared = annualTotals.user02 ? annualTotals.user02.shared : 0;
      user02Personal = annualTotals.user02 ? annualTotals.user02.personal : 0;
    }
    const user01BarRoundingPersonal = (user01Shared === 0 && user01Personal > 0) ? 12 : { topLeft: 12, bottomLeft: 12, topRight: 0, bottomRight: 0 };
    const user01BarRoundingShared = (user01Personal === 0 && user01Shared > 0) ? 12 : { topLeft: 0, bottomLeft: 0, topRight: 12, bottomRight: 12 };
    const user02BarRoundingPersonal = (user02Shared === 0 && user02Personal > 0) ? 12 : { topLeft: 12, bottomLeft: 12, topRight: 0, bottomRight: 0 };
    const user02BarRoundingShared = (user02Personal === 0 && user02Shared > 0) ? 12 : { topLeft: 0, bottomLeft: 0, topRight: 12, bottomRight: 12 };
    
    chart.data.labels = [user01DisplayName, user02DisplayName]; // Use display names here
    chart.data.datasets = [
      {
        label: 'Personal',
        data: [user01Personal, user02Personal],
        backgroundColor: (ctx) => {
          if (ctx.dataIndex === 0) return "rgba(10, 132, 255, 0.5)";
          if (ctx.dataIndex === 1) return "rgba(209, 77, 33, 0.5)"; // Changed to user02-color with opacity
          return 'transparent';
        },
        stack: 'expenses',
        borderRadius: [user01BarRoundingPersonal, user02BarRoundingPersonal],
        borderSkipped: false
      },
      {
        label: 'Shared',
        data: [user01Shared, user02Shared],
        backgroundColor: (ctx) => {
          if (ctx.dataIndex === 0) return "#0a84ff";
          if (ctx.dataIndex === 1) return "#d14d21";
          return 'transparent';
        },
        stack: 'expenses',
        borderRadius: [user01BarRoundingShared, user02BarRoundingShared],
        borderSkipped: false
      }
    ];
    chart.update();
  }
  function updateViewModeText() {
    if (!currentViewTextSpan) return;
    if (viewMode === 'monthly') {
      currentViewTextSpan.textContent = "Monthly View";
    } else {
      currentViewTextSpan.textContent = `Annual View (${activeYear})`;
    }
  }
  function toggleViewMode() {
    if (viewMode === 'monthly') {
      viewMode = 'annual';
    } else {
      viewMode = 'monthly';
    }
    cancelEditMode();
    updateViewModeText();
    updateChart();
  }

function applyRecurring() {
    let changed = false;
    ["user01", "user02"].forEach(p => {
      if (data[p]) {
        const initialLength = data[p].length;
        data[p] = data[p].filter(e => !e.isProjected);
        if (data[p].length !== initialLength) {
          changed = true;
        }
      }
    });
    ["user01", "user02"].forEach(p => {
      if (!data[p]) return;
      const recurringSeriesInfo = new Map();
      data[p].filter(e => e.recurring && !e.isProjected).forEach(e => {
        const seriesKey = `${e.note.toLowerCase()}_${e.isPersonal}`;
        let series = recurringSeriesInfo.get(seriesKey);
        if (!series) {
          series = {
            latestActualEntry: { ...e },
            firstActualMonth: e.month
          };
          recurringSeriesInfo.set(seriesKey, series);
        } else {
          if (getMonthNum(e.month) > getMonthNum(series.latestActualEntry.month)) {
            series.latestActualEntry = { ...e };
          }
          if (getMonthNum(e.month) < getMonthNum(series.firstActualMonth)) {
            series.firstActualMonth = e.month;
          }
        }
      });
      recurringSeriesInfo.forEach(series => {
        const { latestActualEntry, firstActualMonth } = series;
        const [firstYear, firstMonthAbbr] = firstActualMonth.split('-');
        const firstMonthIndex = MONTHS.indexOf(firstMonthAbbr);
        const startYear = parseInt(firstYear);
        const currentYear = new Date().getFullYear();
        const endYear = currentYear + 3;
        for (let year = startYear; year <= endYear; year++) {
          const startMonth = (year === startYear) ? firstMonthIndex : 0;
          const endMonth = 11;
          for (let monthIndex = startMonth; monthIndex <= endMonth; monthIndex++) {
            const targetMonthKey = `${year}-${MONTHS[monthIndex]}`;
            const actualExistingEntry = data[p].find(e =>
              e.month === targetMonthKey &&
              e.recurring &&
              e.note.toLowerCase() === latestActualEntry.note.toLowerCase() &&
              e.isPersonal === latestActualEntry.isPersonal &&
              !e.isProjected
            );
            if (!actualExistingEntry) {
              const templateEntry = data[p].filter(e =>
                e.recurring &&
                e.note.toLowerCase() === latestActualEntry.note.toLowerCase() &&
                e.isPersonal === latestActualEntry.isPersonal &&
                getMonthNum(e.month) <= getMonthNum(targetMonthKey) &&
                !e.isProjected
              ).sort((a, b) => getMonthNum(a.month) - getMonthNum(b.month)).pop();
              if (templateEntry) {
                data[p].push({
                  uuid: generateUUID(),
                  month: targetMonthKey,
                  amount: templateEntry.amount,
                  note: templateEntry.note,
                  logo: templateEntry.logo,
                  recurring: true,
                  isPersonal: templateEntry.isPersonal,
                  isProjected: true
                });
                changed = true;
              }
            }
          }
        }
      });
    });
    if (changed) {
      data.user01.sort((a, b) => getMonthNum(a.month) - getMonthNum(b.month) || a.uuid.localeCompare(b.uuid));
      if (data.user02) {
        data.user02.sort((a, b) => getMonthNum(a.month) - getMonthNum(b.month) || a.uuid.localeCompare(b.uuid));
      }
      save();
    }
}

  function toggleExpenseChart(toggleButtonElement, uuid) {
    if (editMode) return;
    const chartWrapper = document.getElementById(`expenseChartWrapper_${uuid}`);
    const chevronIcon = toggleButtonElement.querySelector('i');
    if (chartWrapper.style.display === 'none') {
      chartWrapper.style.display = 'block';
      toggleButtonElement.classList.add('expanded');
      const expense = getExpenseByUUID(uuid);
      if (expense) {
        drawExpenseHistoryChart(expense, `expenseChartCanvas_${uuid}`, uuid);
      } else {
        console.error("Expense not found for chart with UUID:", uuid);
      }
    } else {
      chartWrapper.style.display = 'none';
      toggleButtonElement.classList.remove('expanded');
      if (expenseChartInstances[uuid]) {
        expenseChartInstances[uuid].destroy();
        delete expenseChartInstances[uuid];
      }
    }
  }
  function getExpenseHistoryData(currentExpense, personKey, year) {
    const amountsByMonth = new Array(12).fill(0);
    const yearPrefix = year.toString();
    const expenseIsPersonal = currentExpense.isPersonal;
    let chartSeriesStartMonthIndex = 0;
    let matcher;
    if (currentExpense.recurring) {
      matcher = e => e.recurring && e.note.toLowerCase() === currentExpense.note.toLowerCase() && e.isPersonal === expenseIsPersonal;
      const allActualSeriesExpenses = data[personKey].filter(e =>
        matcher(e) && !e.isProjected
      ).sort((a, b) => getMonthNum(a.month) - getMonthNum(b.month));
      if (allActualSeriesExpenses.length > 0) {
        const seriesFirstActualMonthKey = allActualSeriesExpenses[0].month;
        const [firstActualYear, firstActualMonthAbbr] = seriesFirstActualMonthKey.split('-');
        if (parseInt(firstActualYear) === year) {
          chartSeriesStartMonthIndex = MONTHS.indexOf(firstActualMonthAbbr);
        } else if (parseInt(firstActualYear) > year) {
          chartSeriesStartMonthIndex = 12;
        }
      } else {
        const [currentExpenseYear, currentExpenseMonthAbbr] = currentExpense.month.split('-');
        if (parseInt(currentExpenseYear) === year) {
          chartSeriesStartMonthIndex = MONTHS.indexOf(currentExpenseMonthAbbr);
        } else if (parseInt(currentExpenseYear) > year) {
          chartSeriesStartMonthIndex = 12;
        }
      }
    } else {
      matcher = e => e.uuid === currentExpense.uuid;
      const [currentExpenseYear, currentExpenseMonthAbbr] = currentExpense.month.split('-');
      if (parseInt(currentExpenseYear) === year) {
        chartSeriesStartMonthIndex = MONTHS.indexOf(currentExpenseMonthAbbr);
      } else {
        chartSeriesStartMonthIndex = 12;
      }
    }
    const entriesForChartYearAndSeries = data[personKey].filter(e => {
      const expenseYear = e.month.substring(0, 4);
      return expenseYear === yearPrefix && matcher(e);
    });
    entriesForChartYearAndSeries.forEach(e => {
      const monthIndex = MONTHS.indexOf(e.month.substring(5, 8));
      if (monthIndex !== -1) {
        amountsByMonth[monthIndex] += e.amount;
      }
    });
    for (let i = 0; i < chartSeriesStartMonthIndex; i++) {
      amountsByMonth[i] = 0;
    }
    return amountsByMonth;
  }
  function drawExpenseHistoryChart(expense, canvasId, uuid) {
    const ctx = document.getElementById(canvasId);
    if (expenseChartInstances[uuid]) {
      expenseChartInstances[uuid].destroy();
    }
    const amounts = getExpenseHistoryData(expense, activePerson, activeYear);
    expenseChartInstances[uuid] = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: MONTHS,
        datasets: [{
          data: amounts,
          backgroundColor: (context) => {
            if (expense.isPersonal) {
              return activePerson === 'user01' ? 'rgba(10, 132, 255, 0.5)' : 'rgba(209, 77, 33, 0.5)'; // Changed to user02-color with opacity
            } else {
              return activePerson === 'user01' ? '#0a84ff' : '#d14d21'; // Changed to user02-color
            }
          },
          borderColor: 'transparent',
          borderRadius: 4,
          barPercentage: 0.8,
          categoryPercentage: 0.8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                let label = context.dataset.label || '';
                if (label) {
                  label += ': ';
                }
                if (context.parsed.y !== null) {
                  label += new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(context.parsed.y);
                }
                return label;
              }
            },
            titleColor: 'white',
            bodyColor: 'white',
            backgroundColor: 'rgba(27, 27, 32, 0.8)'
          }
        },
        scales: {
          x: {
            grid: {
              display: false,
            },
            ticks: {
              color: 'white',
              font: {
                size: 10
              }
            }
          },
          y: {
            beginAtZero: true,
            grid: {
              color: '#2a2a31',
            },
            ticks: {
              color: 'white',
              font: {
                size: 10
              },
              callback: function(value) {
                return '£' + value.toFixed(0);
              }
            }
          }
        }
      }
    });
  }
  function toggleEditMode() {
    editMode = !editMode;
    selectedExpenses = [];
    updateAll();
  }
  function cancelEditMode() {
    editMode = false;
    selectedExpenses = [];
    updateAll();
  }
  function toggleExpenseSelection(checkboxElement, uuid) {
    if (checkboxElement.checked) {
      if (!selectedExpenses.includes(uuid)) {
        selectedExpenses.push(uuid);
      }
    } else {
      selectedExpenses = selectedExpenses.filter(id => id !== uuid);
    }
    renderExpenseHeader();
  }
  function toggleSelectAll() {
    const expensesForMonth = data[activePerson].filter(e => normalizeMonthKey(e.month) === activeMonth);
    const allUUIDsForMonth = expensesForMonth.map(e => e.uuid);
    const allCurrentlySelected = allUUIDsForMonth.length > 0 && allUUIDsForMonth.every(uuid => selectedExpenses.includes(uuid));
    if (allCurrentlySelected) {
      selectedExpenses = selectedExpenses.filter(id => !allUUIDsForMonth.includes(id));
    } else {
      allUUIDsForMonth.forEach(uuid => {
        if (!selectedExpenses.includes(uuid)) {
          selectedExpenses.push(uuid);
        }
      });
    }
    renderExpenses();
    renderExpenseHeader();
  }
  async function confirmDeleteSelected() {
    if (selectedExpenses.length === 0) {
      alert("No expenses selected for deletion.");
      return;
    }
    const actualSelected = [];
    const projectedSelected = [];
    selectedExpenses.forEach(uuid => {
      const expense = getExpenseByUUID(uuid);
      if (expense) {
        if (expense.isProjected) {
          projectedSelected.push(uuid);
        } else {
          actualSelected.push(uuid);
        }
      }
    });
    if (projectedSelected.length > 0) {
      alert("You have selected projected expenses. Projected expenses cannot be deleted directly. Please deselect them or delete their actual entry to stop their projection.");
      return;
    }
    const hasActualRecurringSelected = actualSelected.some(uuid => {
      const expense = getExpenseByUUID(uuid);
      return expense && expense.recurring;
    });
    let confirmationMessage = `Are you sure you want to delete ${actualSelected.length} selected expense(s)?`;
    if (hasActualRecurringSelected) {
      confirmationMessage += "\n\n(Note: If any of these are recurring, only the selected occurrence(s) will be deleted, not future ones. To stop a recurring series, use the single delete button on one of its actual entries.)";
    }
    if (!confirm(confirmationMessage)) {
      return;
    }

    const { error } = await mySupabaseClient
      .from('expenses')
      .delete()
      .in('id', actualSelected)
      .eq('person', activePerson);

    if (error) {
      console.error("Error deleting selected expenses from Supabase:", error);
      alert("Error deleting selected expenses. Please check the console.");
      return;
    }

    data[activePerson] = data[activePerson].filter(e => !actualSelected.includes(e.uuid));
    save();
    cancelEditMode();
  }

  async function fetchExpensesFromSupabase() {
    if (!mySupabaseClient) {
        console.error("Supabase client is not initialized. Cannot fetch expenses.");
        alert("Application error: Supabase connection not established. Please refresh.");
        return;
    }
    if (!currentUser) {
        data.user01 = [];
        data.user02 = [];
        return;
    }

    let { data: allHouseholdExpenses, error: fetchError } = await mySupabaseClient
        .from('expenses')
        .select('*')
        .order('month', { ascending: true })
        .order('created_at', { ascending: true });

    if (fetchError) {
        console.error("Error fetching household expenses:", fetchError);
        alert("Error loading household expenses. Please check the console.");
        return;
    }

    data.user01 = allHouseholdExpenses.filter(e => e.person === 'user01').map(e => ({
        ...e,
        uuid: e.id,
        isPersonal: e.isPersonal,
        isProjected: e.isProjected,
        amount: parseFloat(e.amount)
    }));
    data.user02 = allHouseholdExpenses.filter(e => e.person === 'user02').map(e => ({
        ...e,
        uuid: e.id,
        isPersonal: e.isPersonal,
        isProjected: e.isProjected,
        amount: parseFloat(e.amount)
    }));

    updateLogosForAllExpenses();
}

  async function updateAll() {
    // NEW: Fetch all household profiles first
    if (loggedInUserProfile && loggedInUserProfile.household_id) {
        const { data: profiles, error: profilesError } = await mySupabaseClient
            .from('profiles')
            .select('*')
            .eq('household_id', loggedInUserProfile.household_id);

        if (profilesError) {
            console.error("Error fetching household profiles:", profilesError);
            // Decide how to handle this error, e.g., proceed with default names, or alert
        } else {
            householdProfilesMap.clear();
            profiles.forEach(profile => {
                householdProfilesMap.set(profile.role, profile);
            });
        }
    }


    await fetchExpensesFromSupabase();

    ["user01", "user02"].forEach(p => {
      if (data[p]) {
        data[p] = data[p].filter(e => !e.isProjected);
      }
    });

    applyRecurring();

    renderYears();
    renderMonths();
    updateViewModeText();
    updateChart();
    updateBalance();
    renderExpenseHeader();
    renderExpenses();
  }

  function migrateData() {
    let changed = false;
    ["user01", "user02"].forEach(p => {
      data[p].forEach(e => {
        const normalized = normalizeMonthKey(e.month);
        if (normalized !== e.month) {
          e.month = normalized;
          changed = true;
        }
      });
    });
    if (changed) {
      save();
    }
  }
  function normalizeExpenseData() {
    let changed = false;
    ["user01", "user02"].forEach(p => {
      data[p].forEach(e => {
        if (!e.uuid) {
          e.uuid = generateUUID();
          changed = true;
        }
        const wasRecurringString = e.recurring === "yes";
        e.recurring = (e.recurring === true || wasRecurringString);
        if (wasRecurringString) changed = true;
        if (e.baseId) {
          delete e.baseId;
          changed = true;
        }
        if (e.isPersonal === undefined) {
          e.isPersonal = false;
          changed = true;
        }
        if (e.isProjected === undefined) {
          e.isProjected = false;
          changed = true;
        }
      });
    });
    if (changed) {
      save();
    }
  }

async function initApp() {
    if (!mySupabaseClient) {
        console.error("initApp: Supabase client is not available. Aborting initialization.");
        return;
    }

    initializeDOMElements();

    noteInput.addEventListener('input', showSuggestions);
    noteInput.addEventListener('focus', showSuggestions);
    noteInput.addEventListener('blur', hideSuggestions);

    if (!currentUser) {
        const { data: { session }, error } = await mySupabaseClient.auth.getSession();
        if (session) {
            currentUser = session.user;
            const { data: profileData, error: profileError } = await mySupabaseClient
                .from('profiles')
                .select('*')
                .eq('user_id', currentUser.id)
                .single();

            if (profileError) {
                console.error("Error fetching user profile during initApp:", profileError);
                await mySupabaseClient.auth.signOut();
                currentUser = null;
                loggedInUserProfile = null;
            } else {
                loggedInUserProfile = profileData;
            }
        }
    }

    updateAuthUI();

    if (currentUser && loggedInUserProfile) {
        migrateData();
        normalizeExpenseData();
        await updateAll();
    } else {
        appContentWrapper.style.display = 'none';
        authContainer.style.display = 'block';
    }
}

  document.addEventListener('DOMContentLoaded', initApp);

</script>
</body>
</html>
