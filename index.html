<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Home Bill Tracker</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<style>
:root {
--bg: #0e0e11;
--card: #1b1b20;
--text: #f5f5f7;
--muted: #9a9aa0;
--accent1: #0a84ff;
--accent2: #ff375f;
--danger: #ff453a;
--radius: 18px;
}
* {
box-sizing: border-box;
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}
body {
margin: 0;
background: var(--bg);
color: var(--text);
padding: 20px;
}
.container {
max-width: 900px;
margin: auto;
}
h1 {
text-align: center;
margin-bottom: 6px;
}
.balance {
text-align: center;
color: var(--muted);
margin-bottom: 16px;
display: flex;
flex-direction: column;
align-items: center;
gap: 8px;
}
/* Style for the new settlement action button */
.balance .action-button {
background: #2a2a31;
color: var(--accent1);
padding: 6px 16px;
border-radius: 10px;
font-weight: 500;
font-size: 0.85rem;
cursor: pointer;
border: none;
display: inline-flex;
align-items: center;
justify-content: center;
gap: 6px;
width: auto;
box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.balance .action-button:hover {
background: #3a3a41;
}
.balance .action-button:active {
opacity: 0.85;
}
.card {
background: var(--card);
border-radius: var(--radius);
padding: 16px;
margin-bottom: 16px;
}
.chart-wrapper {
max-width: 520px;
margin: 0 auto;
}
canvas {
max-height: 160px;
}
/* MONTH AND YEAR TABS */
.month-tabs, .year-tabs {
display: flex;
gap: 8px;
overflow-x: auto;
justify-content: center;
margin-bottom: 8px;
}
.year-tabs {
margin-bottom: 0; /* Remove default margin to control with separator */
}
.year-month-separator {
border-bottom: 1px solid #2a2a31;
margin: 8px 0 16px 0; /* Add margin below separator */
}
.month-tab, .year-tab {
padding: 8px 14px;
border-radius: 14px;
background: #2a2a31;
font-size: 0.85rem;
cursor: pointer;
white-space: nowrap;
}
.month-tab.active, .year-tab.active {
background: var(--accent1);
}
/* New: View Switcher */
.view-switcher {
display: flex;
justify-content: center;
align-items: center;
gap: 15px;
margin-top: 10px;
margin-bottom: 10px;
color: var(--muted);
font-size: 0.9rem;
}
.view-switcher button {
background: none;
border: none;
color: var(--muted);
padding: 5px;
cursor: pointer;
font-size: 1.2rem;
width: auto;
}
.view-switcher button:hover {
color: var(--text);
}
/* FORM */
.form {
display: grid;
grid-template-columns: 0.6fr 1.5fr 0.6fr 0.6fr auto; /* Adjusted for amount, note, recurring, shared, button */
gap: 8px;
}
@media (max-width: 600px) {
.form {
grid-template-columns: 1fr;
  }
}
input, select {
background: #2a2a31;
border: none;
border-radius: 14px;
padding: 12px;
color: var(--text);
width: 100%;
}
button {
border: none;
border-radius: 14px;
padding: 12px 18px;
background: var(--accent1);
color: white;
font-weight: 600;
cursor: pointer;
width: 100%;
}
button:active {
opacity: 0.85;
}
button.disabled, .action-button.disabled {
background-color: #555 !important; /* Force greyed-out */
cursor: not-allowed;
opacity: 0.7;
}
/* EXPENSE LIST */
.expense {
display: flex;
flex-wrap: wrap;
justify-content: space-between;
align-items: center;
padding: 10px 0;
border-bottom: 1px solid #2a2a31;
}
.expense-left {
display: flex;
align-items: center;
gap: 8px;
}
.logo {
width: 20px;
height: 20px;
border-radius: 4px;
}
/* Generic receipt icon style when no specific logo */
.expense-left .fa-receipt {
font-size: 20px;
width: 20px;
text-align: center;
}
.actions {
display: flex;
gap: 10px;
align-items: center;
}
.action {
font-size: 0.8rem;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
}
.action.delete {
color: var(--danger);
}
/* New CSS for the chevron expand/collapse icon */
.expand-chart-toggle i {
transition: transform 0.2s ease-in-out;
}
.expand-chart-toggle.expanded i {
transform: rotate(180deg);
}
/* New CSS for the individual expense chart container */
.expense-chart-container {
width: 100%;
margin-top: 10px;
padding-top: 10px;
border-top: 1px dashed #2a2a31;
max-width: 100%;
}
.expense-chart-container canvas {
max-height: 120px;
width: 100% !important;
height: auto !important;
}
/* Recurring icon specific styling */
.recurring-indicator {
color: var(--accent1);
margin-left: 5px;
font-size: 0.75rem;
}
/* Personal indicator specific styling */
.personal-indicator {
color: var(--muted); /* Muted color for personal icon */
margin-left: 5px;
font-size: 0.85rem;
}
/* PROFILES */
.profiles {
display: flex;
justify-content: center;
align-items: center;
gap: 24px;
margin-top: 12px;
margin-bottom: 16px;
}
.profile {
width: 64px;
height: 64px;
border-radius: 50%;
border: 3px solid transparent;
cursor: pointer;
}
.profile.active {
border-color: var(--accent1);
}
/* EXPORT/IMPORT BUTTONS */
.export {
display: flex;
justify-content: center;
align-items: center;
gap: 10px;
}
.export button {
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
}
/* Auto-suggestion Styles */
.note-input-wrapper {
position: relative;
}
.suggestions-dropdown {
position: absolute;
top: calc(100% + 5px);
left: 0;
right: 0;
background: var(--card);
border-radius: 10px;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
max-height: 120px;
overflow-y: auto;
z-index: 100;
display: none;
width: 100%;
}
.suggestions-dropdown div {
padding: 8px 12px;
cursor: pointer;
}
.suggestions-dropdown div:hover {
background: #2a2a31;
}
/* New CSS for the expense header and avatar */
.expense-header-content {
display: flex;
align-items: center;
justify-content: space-between; /* Added to push actions to the right */
gap: 8px;
margin-bottom: 8px;
font-weight: 600;
}
.expense-header-info {
display: flex;
align-items: center;
gap: 8px;
}
.expense-header-actions {
display: flex;
gap: 8px;
}
.expense-header-actions .action-button {
padding: 4px 12px; /* Slightly smaller for header */
font-size: 0.8rem;
}
/* Style for multi-select delete button */
.expense-header-actions .action-button.delete-selected {
background-color: var(--danger);
color: white;
}
.expense-header-avatar {
width: 28px;
height: 28px;
border-radius: 50%;
object-fit: cover;
}
.expense-separator {
border-bottom: 1px solid #2a2a31;
margin-bottom: 10px;
}
/* Checkbox styling */
input[type="checkbox"].expense-select-checkbox {
appearance: none;
background-color: #2a2a31;
margin: 0;
font: inherit;
color: var(--text);
width: 0.7em; /* Reduced size */
height: 0.7em; /* Reduced size */
border: 0.08em solid currentColor; /* Reduced border */
border-radius: 0.08em; /* Reduced border-radius */
transform: translateY(-0.075em);
display: grid;
place-content: center;
cursor: pointer;
vertical-align: middle;
margin-right: 6px; /* Spacing from next item */
}
input[type="checkbox"].expense-select-checkbox::before {
content: "";
width: 0.4em; /* Reduced size */
height: 0.4em; /* Reduced size */
transform: scale(0);
transition: transform 120ms ease-in-out;
box-shadow: inset 1em 1em var(--accent1);
background-color: CanvasText;
clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
}
input[type="checkbox"].expense-select-checkbox:checked::before {
transform: scale(1);
}
input[type="checkbox"].expense-select-checkbox:focus {
outline: max(2px, 0.15em) solid currentColor;
outline-offset: max(2px, 0.15em);
}
/* Footer Styling */
.footer {
margin-top: 40px;
padding-bottom: 20px;
text-align: center;
font-size: 0.9em;
color: var(--muted);
line-height: 1;
}
.footer-link {
color: var(--muted);
text-decoration: none;
display: inline-block;
vertical-align: middle;
}
.footer-link:hover {
color: var(--text);
}
.footer-link .footer-icon {
font-size: 1.5em;
padding: 0 5px;
color: inherit;
}
.footer span {
vertical-align: middle;
}

.action.delete.disabled,
.action.delete.disabled:hover {
  color: var(--muted);          /* grey/muted color from your theme */
  cursor: not-allowed;
  opacity: 0.6;
}

.action.delete.disabled:active {
  opacity: 0.6;
}

</style>
</head>
<body>
<div class="container">
<h1>Bills Overview</h1>
<div class="balance" id="balanceText"></div>
<div class="profiles">
<img src="assets/person001.png" id="francisBtn" class="profile active" onclick="selectPerson('francis')">
<img src="assets/person002.png" id="fionaBtn" class="profile" onclick="selectPerson('fiona')">
</div>
<!-- New: View Switcher -->
<div class="view-switcher">
<button id="prevViewBtn" onclick="toggleViewMode()"><i class="fa-solid fa-chevron-left"></i></button>
<span id="currentViewText">Monthly View</span>
<button id="nextViewBtn" onclick="toggleViewMode()"><i class="fa-solid fa-chevron-right"></i></button>
</div>
<div class="card">
<div class="chart-wrapper">
<canvas id="billChart"></canvas>
</div>
</div>
<div class="card">
<div class="year-tabs" id="yearTabs"></div>
<div class="year-month-separator"></div>
<div class="month-tabs" id="monthTabs"></div>
</div>
<div class="card">
<div class="form">
<input id="amountInput" type="number" step="0.01" placeholder="£ amount">
<div class="note-input-wrapper">
<input id="noteInput" type="text" placeholder="Description or brand">
<div id="suggestions" class="suggestions-dropdown"></div>
</div>
<select id="recurringInput">
<option value="no">One-off</option>
<option value="yes">Recurring</option>
</select>
<select id="sharedStatusInput">
<option value="shared">Shared</option>
<option value="personal">Personal</option>
</select>
<button onclick="addExpense()">Add</button>
</div>
</div>
<div class="card">
<div id="expenseHeader"></div>
<div id="expenseList"></div>
</div>
<div class="card export">
<button onclick="importJSON()">
<i class="fa-solid fa-file-arrow-up"></i> Import JSON
</button>
<button onclick="exportJSON()">
<i class="fa-solid fa-file-arrow-down"></i> Export JSON
</button>
</div>
</div>
<div class="footer">
<a href="https://www.linkedin.com/in/francisarcas/" target="_blank" class="footer-link" title="Francis Arcas LinkedIn">
<i class="fa-brands fa-linkedin footer-icon"></i>
</a>
<span style="margin: 0 10px;">|</span>
<a href="https://github.com/francisarcas/homebills" target="_blank" class="footer-link" title="Home Bills GitHub Repository">
<i class="fa-brands fa-github footer-icon"></i>
</a>
</div>

<script>
const MONTHS = ["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];
// Canonical list of brands for auto-suggestions, sorted alphabetically
const SUGGESTION_BRANDS = [
"amex", "affinity water", "amazon", "b&q", "barclays", "british airways", "costco", "council tax", "eurostar",
"hotel", "hsbc", "hyperoptic", "iberia", "insite energy", "itsu", "john lewis", "klarna", "lidl", "lottery", "lner", "m&s", "morrisons", "mortgage", "netflix",
"octopus energy", "play station", "prime", "renfe", "revolut", "rent", "ryanair", "sainsbury's", "strava", "tfl", "tk.max", "accommodation", "third space"
].sort();
// Rules for logo detection (more comprehensive, order might matter for precedence)
const BRAND_LOGO_RULES = [
  { keywords: ["affinity water"], logo: "assets/logos/affinitywater.png" },
  { keywords: ["amex"], logo: "assets/logos/amex.png" },
  { keywords: ["amazon"], logo: "assets/logos/amazon.png" },
  { keywords: ["b&q"], logo: "assets/logos/bandq.png" },
  { keywords: ["barclays"], logo: "assets/logos/barclays.png" },
  { keywords: ["british airways"], logo: "assets/logos/britishairways.png" },
  { keywords: ["costco"], logo: "assets/logos/costco.png" },
  { keywords: ["hyperoptic"], logo: "assets/logos/hyperoptic.png" },
  { keywords: ["hsbc"], logo: "assets/logos/hsbc.png" },
  { keywords: ["iberia"], logo: "assets/logos/iberia.png" },
  { keywords: ["insite energy"], logo: "assets/logos/insiteenergy.png" },
  { keywords: ["itsu"], logo: "assets/logos/itsu.png" },
  { keywords: ["john lewis"], logo: "assets/logos/johnlewis.png" },
  { keywords: ["klarna"], logo: "assets/logos/klarna.png" },
  { keywords: ["lottery"], logo: "assets/logos/lottery.png" },
  { keywords: ["lidl"], logo: "assets/logos/lidl.png" },
  { keywords: ["lner"], logo: "assets/logos/lner.png" },
  { keywords: ["m&s"], logo: "assets/logos/mands.png" },
  { keywords: ["morrisons"], logo: "assets/logos/morrisons.png" },
  { keywords: ["mortgage"], logo: "assets/logos/mortgage.png" },
  { keywords: ["netflix"], logo: "assets/logos/netflix.png" },
  { keywords: ["octopus energy"], logo: "assets/logos/octopusenergy.png" },
  { keywords: ["play station"], logo: "assets/logos/playstation.png" },
  { keywords: ["prime"], logo: "assets/logos/prime.png" },
  { keywords: ["renfe"], logo: "assets/logos/renfe.png" },
  { keywords: ["revolut"], logo: "assets/logos/revolut.png" },
  { keywords: ["rent"], logo: "assets/logos/rent.png" },
  { keywords: ["ryanair"], logo: "assets/logos/ryanair.png" },
  { keywords: ["sainsbury's"], logo: "assets/logos/sainsburys.png" },
  { keywords: ["strava"], logo: "assets/logos/strava.png" },
  { keywords: ["tfl"], logo: "assets/logos/tfl.png" },
  { keywords: ["tk.max"], logo: "assets/logos/tkmax.png" },
  { keywords: ["eurostar"], logo: "assets/logos/eurostar.png" },
  { keywords: ["council tax", "council-tax", "brent council", "brent"], logo: "assets/logos/brent.png" },
  { keywords: ["hotel", "accommodation", "booking.com"], logo: "assets/logos/booking.png" },
  { keywords: ["third space"], logo: "assets/logos/thirdspace.png" }
];
// Helper function to generate UUID with fallback for older browsers
function generateUUID() {
if (typeof crypto !== 'undefined' && crypto.randomUUID) {
return crypto.randomUUID();
  }
// Fallback for older browsers (especially Safari < 15.4)
return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
const r = Math.random() * 16 | 0;
const v = c === 'x' ? r : (r & 0x3 | 0x8);
return v.toString(16);
  });
}
// Helper to get numerical month value for chronological comparisons/sorting
function getMonthNum(monthKey) {
  const year = parseInt(monthKey.substring(0, 4));
  const monthAbbr = monthKey.substring(5, 8);
  const monthIdx = MONTHS.indexOf(monthAbbr);
  if (monthIdx === -1) throw new Error(`Invalid month abbreviation: ${monthAbbr}`);
  return year * 12 + monthIdx;
}
// DOM elements for suggestions
const noteInput = document.getElementById('noteInput');
const suggestionsDiv = document.getElementById('suggestions');
const yearTabsDiv = document.getElementById('yearTabs');
const expenseHeaderDiv = document.getElementById('expenseHeader');
const balanceTextDiv = document.getElementById('balanceText');
const currentViewTextSpan = document.getElementById('currentViewText');
const sharedStatusInput = document.getElementById('sharedStatusInput');
const amountInput = document.getElementById('amountInput');
const recurringInput = document.getElementById('recurringInput');
const expenseListDiv = document.getElementById('expenseList');
const expenseChartInstances = {};
// Global state for multi-select/multi-delete
let editMode = false;
let selectedExpenses = [];
// Auto-suggestion functions
function showSuggestions() {
const inputValue = noteInput.value.toLowerCase();
suggestionsDiv.innerHTML = '';
if (inputValue.length === 0 && document.activeElement !== noteInput) {
suggestionsDiv.style.display = 'none';
return;
  }
const matchingBrands = SUGGESTION_BRANDS.filter(brand =>
brand.includes(inputValue)
  );
if (matchingBrands.length > 0) {
matchingBrands.forEach(brand => {
const suggestionItem = document.createElement('div');
let displayText = brand.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
if (brand === "m&s") displayText = "M&S";
if (brand === "b&q") displayText = "B&Q";
if (brand === "hsbc") displayText = "HSBC";
if (brand === "lner") displayText = "LNER";
if (brand === "tfl") displayText = "TFL";
if (brand === "amex") displayText = "AMEX";
if (brand === "tk.max") displayText = "TK.MAX";
suggestionItem.textContent = displayText;
suggestionItem.onmousedown = (event) => {
event.preventDefault();
selectSuggestion(brand);
      };
suggestionsDiv.appendChild(suggestionItem);
    });
suggestionsDiv.style.display = 'block';
  } else {
suggestionsDiv.style.display = 'none';
  }
}
function selectSuggestion(brandName) {
let capitalizedBrand = brandName.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
if (brandName === "m&s") capitalizedBrand = "M&S";
if (brandName === "b&q") capitalizedBrand = "B&Q";
if (brandName === "hsbc") capitalizedBrand = "HSBC";
if (brandName === "lner") capitalizedBrand = "LNER";
if (brandName === "tfl") capitalizedBrand = "TFL";
if (brandName === "amex") capitalizedBrand = "AMEX";
if (brandName === "tk.max") capitalizedBrand = "TK.MAX";
noteInput.value = capitalizedBrand;
suggestionsDiv.style.display = 'none';
}
function hideSuggestions() {
setTimeout(() => {
if (document.activeElement !== noteInput && !suggestionsDiv.contains(document.activeElement)) {
suggestionsDiv.style.display = 'none';
    }
  }, 100);
}
// Attach event listeners
noteInput.addEventListener('input', showSuggestions);
noteInput.addEventListener('focus', showSuggestions);
noteInput.addEventListener('blur', hideSuggestions);
function normalizeMonthKey(monthKey) {
if (monthKey && monthKey.match(/^\d{4}-\d{2}$/)) {
const [year, monthNum] = monthKey.split('-');
const monthIndex = parseInt(monthNum, 10) - 1;
if (monthIndex >= 0 && monthIndex < 12) {
return `${year}-${MONTHS[monthIndex]}`;
    }
  }
return monthKey;
}
function currentMonthKey() {
const d = new Date();
return `${d.getFullYear()}-${MONTHS[d.getMonth()]}`;
}
// Initialize activeYear and activeMonth
const today = new Date();
let activeYear = today.getFullYear();
let activeMonth = `${activeYear}-${MONTHS[today.getMonth()]}`;
let activePerson = "francis";
let viewMode = 'monthly';
const data = JSON.parse(localStorage.getItem("billData")) || {
francis: [],
fiona: [],
settlements: {}
};
// Ensure settlements object exists even if loaded from older data structure
if (!data.settlements) {
data.settlements = {};
save();
}
// Migrate old month formats to the new YYYY-MMM format on load
function migrateData() {
let changed = false;
  ["francis", "fiona"].forEach(p => {
data[p].forEach(e => {
const normalized = normalizeMonthKey(e.month);
if (normalized !== e.month) {
e.month = normalized;
changed = true;
      }
    });
  });
if (changed) {
save();
console.log("Migrated old month formats in localStorage.");
  }
}
// Function to ensure data integrity for baseId, recurring, and isPersonal flags, AND UUIDs
function normalizeExpenseData() {
let changed = false;
    ["francis", "fiona"].forEach(p => {
data[p].forEach(e => {
// New: Ensure UUID exists
if (!e.uuid) {
e.uuid = generateUUID();
changed = true;
            }
// Normalize recurring flag (from string to boolean if needed)
const wasRecurringString = e.recurring === "yes";
e.recurring = (e.recurring === true || wasRecurringString);
if (wasRecurringString) changed = true;
// Remove baseId if present
if (e.baseId) {
delete e.baseId;
changed = true;
            }
// New: Ensure isPersonal flag exists, default to false
if (e.isPersonal === undefined) {
e.isPersonal = false;
changed = true;
            }
// New: Ensure isProjected flag exists, default to false
if (e.isProjected === undefined) {
e.isProjected = false;
changed = true;
            }
        });
    });
if (changed) {
save();
console.log("Normalized expense data (baseId, recurring flags, isPersonal, isProjected, and UUIDs).");
    }
}
function save() {
localStorage.setItem("billData", JSON.stringify(data));
}
function capitalise(name) {
return name.charAt(0).toUpperCase() + name.slice(1);
}
// Updated detectLogo to use BRAND_LOGO_RULES for more flexible matching
function detectLogo(note) {
const lowerCaseNote = note.toLowerCase();
for (const rule of BRAND_LOGO_RULES) {
for (const keyword of rule.keywords) {
if (lowerCaseNote.includes(keyword)) {
return rule.logo;
      }
    }
  }
return null;
}
// New function to update logos for all existing expenses
function updateLogosForAllExpenses() {
let changed = false;
  ["francis", "fiona"].forEach(p => {
data[p].forEach(e => {
const newLogo = detectLogo(e.note);
if (e.logo !== newLogo) {
e.logo = newLogo;
changed = true;
      }
    });
  });
if (changed) {
save();
console.log("Updated logos for existing expenses based on new rules.");
  }
}
function getYears() {
const years = new Set();
years.add(new Date().getFullYear().toString());
  ["francis", "fiona"].forEach(p => {
data[p].forEach(e => {
if (e.month) {
years.add(e.month.substring(0, 4));
      }
    });
  });
return [...years].sort((a, b) => parseInt(a) - parseInt(b));
}
function renderYears() {
yearTabsDiv.innerHTML = "";
getYears().forEach(year => {
const tab = document.createElement("div");
tab.className = "year-tab" + (year === activeYear.toString() ? " active" : "");
tab.textContent = year;
tab.onclick = () => {
activeYear = parseInt(year);
const currentMonthAbbr = activeMonth.substring(5, 8);
activeMonth = `${activeYear}-${currentMonthAbbr}`;
updateAll();
    };
yearTabsDiv.appendChild(tab);
  });
}
function renderMonths() {
monthTabs.innerHTML = "";
MONTHS.forEach(m => {
const tab = document.createElement("div");
tab.className = "month-tab" + ((`${activeYear}-${m}`) === activeMonth ? " active" : "");
tab.textContent = m;
tab.onclick = () => {
activeMonth = `${activeYear}-${m}`;
updateAll();
    };
monthTabs.appendChild(tab);
  });
}
// New function to mark a month as settled or unsettled
function markMonthAsSettled(status) {
data.settlements[activeMonth] = status;
save();
updateAll();
}
// New function to get shared and personal expenses for a specific month
function getMonthlyExpenses(personKey, monthKey) {
const expenses = data[personKey].filter(e => normalizeMonthKey(e.month) === monthKey);
const shared = expenses.filter(e => !e.isPersonal).reduce((sum, e) => sum + e.amount, 0);
const personal = expenses.filter(e => e.isPersonal).reduce((sum, e) => sum + e.amount, 0);
return { shared, personal };
}
// Updated calculateAnnualTotals to return shared/personal split
function calculateAnnualTotals() {
const annualTotals = {
francis: { shared: 0, personal: 0 }
    };
if (data.fiona) {
annualTotals.fiona = { shared: 0, personal: 0 };
    }
const yearPrefix = activeYear.toString();
    ["francis", "fiona"].forEach(personKey => {
if (!data[personKey]) return;
// Filter for only actual entries to determine recurring series start/latest actual amount
const actualPersonExpenses = data[personKey].filter(e => !e.isProjected);
const latestRecurringSharedAmounts = {}; // note.toLowerCase() -> { amount, month }
const latestRecurringPersonalAmounts = {}; // note.toLowerCase() -> { amount, month }
const firstRecurringSharedMonth = {}; // note.toLowerCase() -> month string
const firstRecurringPersonalMonth = {}; // note.toLowerCase() -> month string
// Determine latest actual amounts and first actual occurrence month for all recurring series
actualPersonExpenses.filter(e => e.recurring).forEach(e => {
const key = e.note.toLowerCase();
const currentFirstMonth = e.isPersonal ? firstRecurringPersonalMonth[key] : firstRecurringSharedMonth[key];
if (!currentFirstMonth || getMonthNum(e.month) < getMonthNum(currentFirstMonth)) {
if (e.isPersonal) firstRecurringPersonalMonth[key] = e.month;
else firstRecurringSharedMonth[key] = e.month;
            }
const currentLatestAmount = e.isPersonal ? latestRecurringPersonalAmounts[key] : latestRecurringSharedAmounts[key];
if (!currentLatestAmount || getMonthNum(e.month) > getMonthNum(currentLatestAmount.month)) {
if (e.isPersonal) latestRecurringPersonalAmounts[key] = { amount: e.amount, month: e.month };
else latestRecurringSharedAmounts[key] = { amount: e.amount, month: e.month };
            }
        });
for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
const monthOfYear = MONTHS[monthIndex];
const currentYearMonthKey = `${yearPrefix}-${monthOfYear}`;
let monthlySharedTotal = 0;
let monthlyPersonalTotal = 0;
// Get all entries (actual and projected) for the current month
const expensesForThisMonth = data[personKey].filter(e => e.month === currentYearMonthKey);
expensesForThisMonth.forEach(e => {
if (e.isPersonal) {
monthlyPersonalTotal += e.amount;
                } else {
monthlySharedTotal += e.amount;
                }
            });
// The applyRecurring function already populates data[personKey] with projected entries.
// So, we just need to sum up what's in the data for this month.
// No need for separate projection logic here.
annualTotals[personKey].shared += monthlySharedTotal;
annualTotals[personKey].personal += monthlyPersonalTotal;
        }
    });
return annualTotals;
}
function updateBalance() {
// Balance calculation only considers SHARED expenses
const francisMonthly = getMonthlyExpenses("francis", activeMonth);
const fionaMonthly = getMonthlyExpenses("fiona", activeMonth);
const a = francisMonthly.shared;
const b = fionaMonthly.shared;
const diff = Math.abs(a - b) / 2;
let balanceMessage = "";
let actionButton = "";
const isSettled = data.settlements[activeMonth];
if (isSettled) {
balanceMessage = `All settled for ${activeMonth}!`;
actionButton = `<button class="action-button" onclick="markMonthAsSettled(false)"><i class="fa-solid fa-undo"></i> Unmark as Settled</button>`;
  } else {
if (a === b) {
balanceMessage = "All settled";
    } else if (a > b) {
balanceMessage = `Fiona owes Francis £${diff.toFixed(2)}`;
actionButton = `<button class="action-button" onclick="markMonthAsSettled(true)"><i class="fa-solid fa-check"></i> Mark as Settled</button>`;
    } else {
balanceMessage = `Francis owes Fiona £${diff.toFixed(2)}`;
actionButton = `<button class="action-button" onclick="markMonthAsSettled(true)"><i class="fa-solid fa-check"></i> Mark as Settled</button>`;
    }
  }
balanceTextDiv.innerHTML = `
    <span>${balanceMessage}</span>
${actionButton}
  `;
}
// New: Render expense header with edit actions
function renderExpenseHeader() {
const avatarImgSrc = (activePerson === "francis") ? "assets/person001.png" : "assets/person002.png";
let actionButtonsHtml = '';
if (!editMode) {
actionButtonsHtml = `<button class="action-button" onclick="toggleEditMode()"><i class="fa-solid fa-pen-to-square"></i> Edit</button>`;
  } else {
const expensesForMonth = data[activePerson].filter(e => normalizeMonthKey(e.month) === activeMonth);
const allSelected = expensesForMonth.length > 0 && expensesForMonth.every(e => selectedExpenses.includes(e.uuid));
const deleteButtonDisabled = selectedExpenses.length === 0 ? 'disabled' : '';
actionButtonsHtml = `
      <button class="action-button" onclick="cancelEditMode()" title="Cancel Edit"><i class="fa-solid fa-xmark"></i></button>
      <button class="action-button" onclick="toggleSelectAll()" title="${allSelected ? 'Deselect All' : 'Select All'}"><i class="fa-regular fa-square-check"></i></button>
      <button class="action-button delete-selected ${deleteButtonDisabled}" onclick="confirmDeleteSelected()" ${deleteButtonDisabled} title="Delete Selected Expenses"><i class="fa-solid fa-trash"></i></button>
    `;
  }
expenseHeaderDiv.innerHTML = `
    <div class="expense-header-content">
      <div class="expense-header-info">
        <img src="${avatarImgSrc}" class="expense-header-avatar">
        <span>${capitalise(activePerson)} – ${activeMonth}</span>
      </div>
      <div class="expense-header-actions">
${actionButtonsHtml}
      </div>
    </div>
    <div class="expense-separator"></div>
  `;
}
// Helper to get expense object by UUID
function getExpenseByUUID(uuid) {
return data[activePerson].find(e => e.uuid === uuid);
}
// Helper to get expense index by UUID
function getExpenseIndexByUUID(uuid) {
return data[activePerson].findIndex(e => e.uuid === uuid);
}
function renderExpenses() {
// Clear any existing charts
for (const uuid in expenseChartInstances) {
if (expenseChartInstances.hasOwnProperty(uuid)) {
expenseChartInstances[uuid].destroy();
    }
  }
Object.keys(expenseChartInstances).forEach(key => delete expenseChartInstances[key]);
expenseListDiv.innerHTML = "";
// Filter expenses for the active person and active month
// Sort by whether it's projected (projected last), then by amount, then note
const expensesForMonth = data[activePerson]
    .filter(e => normalizeMonthKey(e.month) === activeMonth)
    .sort((a, b) => {
// Actual entries first, then projected
if (a.isProjected && !b.isProjected) return 1;
if (!a.isProjected && b.isProjected) return -1;
// Then by amount (descending)
if (a.amount < b.amount) return 1;
if (a.amount > b.amount) return -1;
// Then by note
return a.note.localeCompare(b.note);
    });
expensesForMonth.forEach((e) => {
const expenseUuid = e.uuid;
const row = document.createElement("div");
row.className = "expense";
const iconContent = e.logo ? `<img class="logo" src="${e.logo}" onerror="this.remove()">` : `<i class="fa-solid fa-receipt"></i>`;
const recurringIndicator = e.recurring ? `<i class="fa-solid fa-repeat recurring-indicator" title="Recurring expense"></i>` : '';
const personalIndicator = e.isPersonal ? `<i class="fa-solid fa-user personal-indicator" title="Personal expense (not shared)"></i>` : '';
const projectedIndicator = e.isProjected ? `<i class="fa-solid fa-clock recurring-indicator" title="This is a forecast based on your recurring bill – not yet paid"></i>` : ''; // New projected indicator
let actionsHtml = '';
let checkboxHtml = '';
if (editMode) {
const isChecked = selectedExpenses.includes(expenseUuid) ? 'checked' : '';
checkboxHtml = `<input type="checkbox" class="expense-select-checkbox" ${isChecked} onchange="toggleExpenseSelection(this, '${expenseUuid}')">`;
    } else {
actionsHtml = `
  ${personalIndicator}
  ${projectedIndicator}
  <span class="action expand-chart-toggle" data-uuid="${expenseUuid}" onclick="toggleExpenseChart(this, '${expenseUuid}')"><i class="fa-solid fa-chevron-down"></i></span>
  <span class="action" onclick="editExpenseByUUID('${expenseUuid}')"><i class="fa-solid fa-pencil"></i></span>
  <span class="action delete ${e.isProjected ? 'disabled' : ''}" 
        onclick="${e.isProjected ? '' : `deleteExpenseByUUID('${expenseUuid}')`}">
    <i class="fa-solid fa-trash"></i>
  </span>
`;
    }
row.innerHTML = `
      <div class="expense-left">
${iconContent}
        <div>${e.note} ${recurringIndicator}<br><small>£${e.amount.toFixed(2)}</small></div>
      </div>
      <div class="actions">
${checkboxHtml}
${actionsHtml}
      </div>
      <div id="expenseChartWrapper_${expenseUuid}" class="expense-chart-container" style="display:none;">
        <canvas id="expenseChartCanvas_${expenseUuid}"></canvas>
      </div>
    `;
expenseListDiv.appendChild(row);
  });
}
function addExpense() {
const amount = parseFloat(amountInput.value);
const note = noteInput.value.trim();
const isRecurring = recurringInput.value === "yes";
const isPersonal = sharedStatusInput.value === "personal";
// Validation
if (!amount || !note) {
alert("Please enter both amount and description");
return;
  }
if (amount <= 0) {
alert("Amount must be greater than zero");
return;
  }
if (amount > 999999) {
alert("Amount seems too large. Please check.");
return;
  }
const newExpense = {
uuid: generateUUID(),
month: activeMonth,
amount,
note,
logo: detectLogo(note),
recurring: isRecurring,
isPersonal: isPersonal,
isProjected: false // New expenses are always actual, not projected
  };
data[activePerson].push(newExpense);
amountInput.value = "";
noteInput.value = "";
recurringInput.value = "no";
sharedStatusInput.value = "shared";
suggestionsDiv.style.display = 'none';
save();
updateAll();
}
function editExpenseByUUID(uuid) {
// Exit edit mode if active
if (editMode) {
cancelEditMode();
setTimeout(() => editExpenseByUUID(uuid), 100);
return;
  }
const expense = getExpenseByUUID(uuid);
if (!expense) {
console.error("Expense not found for editing with UUID:", uuid);
return;
  }
// Prevent editing projected expenses directly
if (expense.isProjected) {
alert("Projected expenses cannot be edited directly. Please edit an actual entry for this recurring series.");
return;
  }
const newNote = prompt("Description", expense.note);
if (newNote === null) return;
const newAmountStr = prompt("Amount", expense.amount);
if (newAmountStr === null) return;
if (!newNote.trim() || !newAmountStr.trim()) {
alert("Description and Amount cannot be empty.");
return;
  }
const newAmount = parseFloat(newAmountStr);
// Validation
if (isNaN(newAmount) || newAmount <= 0) {
alert("Please enter a valid amount greater than zero");
return;
  }
if (newAmount > 999999) {
alert("Amount seems too large. Please check.");
return;
  }
// Store original values before modification
const originalAmount = expense.amount;
const originalNote = expense.note;
// Handle note change for recurring expenses
let dataChanged = false;
if (expense.recurring && newNote.trim().toLowerCase() !== originalNote.toLowerCase()) {
  if (confirm("You changed the description for a recurring expense. Do you want to update the description for all occurrences of this series?")) {
    data[activePerson].forEach(e => {
      if (e.recurring && e.note.toLowerCase() === originalNote.toLowerCase() && e.isPersonal === expense.isPersonal) {
        e.note = newNote.trim();
        e.logo = detectLogo(e.note);
        dataChanged = true;
      }
    });
  }
}
expense.note = newNote.trim();
expense.amount = newAmount;
expense.logo = detectLogo(newNote.trim());
// Check if it's a recurring expense and if the amount changed
if (expense.recurring && newAmount !== originalAmount) {
  if (confirm("Do you want to update all future occurrences of this recurring expense to the new amount?")) {
// Update all *actual* future occurrences for this series (based on note)
    data[activePerson].forEach(e => {
      if (e.recurring && e.note.toLowerCase() === expense.note.toLowerCase() && e.isPersonal === expense.isPersonal && getMonthNum(e.month) > getMonthNum(expense.month) && !e.isProjected) {
        e.amount = newAmount;
        dataChanged = true;
      }
    });
  }
}
// If amount or note changed for the current expense, mark dataChanged
if (newAmount !== originalAmount || newNote.trim() !== originalNote) {
dataChanged = true;
  }
if (dataChanged) {
save();
updateAll(); // updateAll will trigger applyRecurring to regenerate projections
  }
}
function deleteExpenseByUUID(uuid) {
// Exit edit mode if active
if (editMode) {
cancelEditMode();
setTimeout(() => deleteExpenseByUUID(uuid), 100);
return;
  }
const expenseToDelete = getExpenseByUUID(uuid);
if (!expenseToDelete) {
console.error("Expense not found for deletion with UUID:", uuid);
return;
  }
if (expenseToDelete.isProjected) {
alert("Projected expenses cannot be deleted directly. Please delete an actual entry for this recurring series to stop its projection.");
return;
  }
// --- New Logic for Recurring Expense Deletion ---
if (expenseToDelete.recurring) {
  if (confirm("This is a recurring expense. Do you want to delete all future occurrences of this series as well?")) {
// User wants to delete future occurrences
// Filter out expenses that are part of this recurring series AND occur AFTER the current month
    data[activePerson] = data[activePerson].filter(e => {
      return !(e.recurring && e.note.toLowerCase() === expenseToDelete.note.toLowerCase() && e.isPersonal === expenseToDelete.isPersonal && getMonthNum(e.month) > getMonthNum(expenseToDelete.month));
    });
    save();
    updateAll(); // Re-project everything from scratch
    return; // Exit function after handling
  }
// If user clicks 'Cancel' on deleting future occurrences,
// fall through to delete only the current expense.
  }
// --- End New Logic ---
// Original logic: Delete only the current expense (if not handled by recurring prompt)
if (!confirm("Delete expense?")) return;
const indexToDelete = getExpenseIndexByUUID(uuid);
if (indexToDelete === -1) {
console.error("Expense not found for deletion with UUID:", uuid);
return;
  }
data[activePerson].splice(indexToDelete, 1);
save();
updateAll();
}
function selectPerson(p) {
activePerson = p;
francisBtn.classList.toggle("active", p === "francis");
fionaBtn.classList.toggle("active", p === "fiona");
cancelEditMode();
updateAll();
}
const chart = new Chart(document.getElementById("billChart"), {
type: "bar",
data: {
labels: ["Francis", "Fiona"],
datasets: []
  },
options: {
indexAxis: "y",
plugins: {
legend: {
display: false
        },
tooltip: {
mode: 'index',
intersect: false,
callbacks: {
label: function(context) {
let label = context.dataset.label || '';
if (label) {
label += ': ';
                    }
if (context.parsed.x !== null) {
label += new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(context.parsed.x);
                    }
return label;
                },
footer: function(tooltipItems) {
let total = 0;
tooltipItems.forEach(function(tooltipItem) {
total += tooltipItem.parsed.x;
                    });
return 'Total: ' + new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(total);
                }
            },
titleColor: 'white',
bodyColor: 'white',
backgroundColor: 'rgba(27, 27, 32, 0.8)'
        }
    },
scales: {
x: {
stacked: true,
ticks: { color: "#f5f5f7" },
grid: { color: "#2a2a31" }
      },
y: {
stacked: true,
ticks: { color: "#f5f5f7" },
grid: { display: false }
      }
    },
elements: {
bar: {
borderRadius: 0
      }
    }
  }
});
function updateChart() {
let francisShared, francisPersonal, fionaShared, fionaPersonal;
if (viewMode === 'monthly') {
const francisMonthly = getMonthlyExpenses("francis", activeMonth);
const fionaMonthly = getMonthlyExpenses("fiona", activeMonth);
francisShared = francisMonthly.shared;
francisPersonal = francisMonthly.personal;
fionaShared = fionaMonthly.shared;
fionaPersonal = fionaMonthly.personal;
    } else {
const annualTotals = calculateAnnualTotals();
francisShared = annualTotals.francis.shared;
francisPersonal = annualTotals.francis.personal;
fionaShared = annualTotals.fiona ? annualTotals.fiona.shared : 0;
fionaPersonal = annualTotals.fiona ? annualTotals.fiona.personal : 0;
    }
const francisBarRoundingPersonal = (francisShared === 0 && francisPersonal > 0) ? 12 : { topLeft: 12, bottomLeft: 12, topRight: 0, bottomRight: 0 };
const francisBarRoundingShared = (francisPersonal === 0 && francisShared > 0) ? 12 : { topLeft: 0, bottomLeft: 0, topRight: 12, bottomRight: 12 };
const fionaBarRoundingPersonal = (fionaShared === 0 && fionaPersonal > 0) ? 12 : { topLeft: 12, bottomLeft: 12, topRight: 0, bottomRight: 0 };
const fionaBarRoundingShared = (fionaPersonal === 0 && fionaShared > 0) ? 12 : { topLeft: 0, bottomLeft: 0, topRight: 12, bottomRight: 12 };
chart.data.labels = ["Francis", "Fiona"];
chart.data.datasets = [
        {
label: 'Personal',
data: [francisPersonal, fionaPersonal],
backgroundColor: (ctx) => {
if (ctx.dataIndex === 0) return "rgba(10, 132, 255, 0.5)";
if (ctx.dataIndex === 1) return "rgba(255, 55, 95, 0.5)";
return 'transparent';
            },
stack: 'expenses',
borderRadius: [francisBarRoundingPersonal, fionaBarRoundingPersonal],
borderSkipped: false
        },
        {
label: 'Shared',
data: [francisShared, fionaShared],
backgroundColor: (ctx) => {
if (ctx.dataIndex === 0) return "#0a84ff";
if (ctx.dataIndex === 1) return "#ff375f";
return 'transparent';
            },
stack: 'expenses',
borderRadius: [francisBarRoundingShared, fionaBarRoundingShared],
borderSkipped: false
        }
    ];
chart.update();
}
function updateViewModeText() {
if (viewMode === 'monthly') {
currentViewTextSpan.textContent = "Monthly View";
    } else {
currentViewTextSpan.textContent = `Annual View (${activeYear})`;
    }
}
function toggleViewMode() {
if (viewMode === 'monthly') {
viewMode = 'annual';
    } else {
viewMode = 'monthly';
    }
cancelEditMode();
updateViewModeText();
updateChart();
}
function exportJSON() {
const blob = new Blob([JSON.stringify(data,null,2)], { type: "application/json" });
const a = document.createElement("a");
a.href = URL.createObjectURL(blob);
a.download = "home-bills.json";
a.click();
}
function importJSON() {
const input = document.createElement('input');
input.type = 'file';
input.accept = 'application/json';
input.onchange = (event) => {
const file = event.target.files[0];
if (file) {
const reader = new FileReader();
reader.onload = (e) => {
try {
const importedData = JSON.parse(e.target.result);
if (importedData.francis && Array.isArray(importedData.francis) &&
importedData.fiona && Array.isArray(importedData.fiona)) {
if (confirm("Are you sure you want to import this data? This will overwrite your current data.")) {
data.francis = importedData.francis;
data.fiona = importedData.fiona;
data.settlements = importedData.settlements || {};
save();
migrateData();
normalizeExpenseData();
updateLogosForAllExpenses();
cancelEditMode();
updateAll();
alert("Data imported successfully!");
            }
          } else {
alert("Invalid JSON file format. Please ensure it's a valid Home Bill Tracker export.");
          }
        } catch (error) {
alert("Error parsing JSON file: " + error.message);
console.error("Error parsing JSON file:", error);
        }
      };
reader.readAsText(file);
    }
  };
input.click();
}
function applyRecurring() {
let changed = false;
// Step 1: Remove all previously projected entries to regenerate them
    ["francis", "fiona"].forEach(p => {
if (data[p]) {
const initialLength = data[p].length;
// Only remove entries that are marked as projected
data[p] = data[p].filter(e => !e.isProjected);
if (data[p].length !== initialLength) {
changed = true;
            }
        }
    });
// Step 2: Identify all *actual* recurring expenses and their series info
    ["francis", "fiona"].forEach(p => {
if (!data[p]) return;
const recurringSeriesInfo = new Map(); // Stores { firstActualMonth, latestActualEntry } for each series
// Iterate through *actual* expenses ONLY to build series info
// This is the critical change: filter for !e.isProjected here
data[p].filter(e => e.recurring && !e.isProjected).forEach(e => {
const seriesKey = `${e.note.toLowerCase()}_${e.isPersonal}`;
let series = recurringSeriesInfo.get(seriesKey);
if (!series) {
series = {
latestActualEntry: { ...e }, // This is an actual entry
firstActualMonth: e.month
                };
recurringSeriesInfo.set(seriesKey, series);
            } else {
// Ensure we are always comparing against actual entries for the latest/first
if (getMonthNum(e.month) > getMonthNum(series.latestActualEntry.month)) {
series.latestActualEntry = { ...e };
                }
if (getMonthNum(e.month) < getMonthNum(series.firstActualMonth)) {
series.firstActualMonth = e.month;
                }
            }
        });
// Step 3: Project recurring expenses
recurringSeriesInfo.forEach(series => {
const { latestActualEntry, firstActualMonth } = series;
const [firstYear, firstMonthAbbr] = firstActualMonth.split('-');
const firstMonthIndex = MONTHS.indexOf(firstMonthAbbr);
const startYear = parseInt(firstYear);
const currentYear = new Date().getFullYear();
const endYear = currentYear + 3;
for (let year = startYear; year <= endYear; year++) {
const startMonth = (year === startYear) ? firstMonthIndex : 0;
const endMonth = 11; // Project up to December of the active year
for (let monthIndex = startMonth; monthIndex <= endMonth; monthIndex++) {
const targetMonthKey = `${year}-${MONTHS[monthIndex]}`;
// Check if an *actual* entry already exists for this month and series
const actualExistingEntry = data[p].find(e =>
e.month === targetMonthKey &&
e.recurring &&
e.note.toLowerCase() === latestActualEntry.note.toLowerCase() &&
e.isPersonal === latestActualEntry.isPersonal &&
                            !e.isProjected // Only consider actual entries
                        );
if (!actualExistingEntry) {
// Find the latest *actual* amount up to this target month
// This lookup is already correct, filtering for !e.isProjected
const templateEntry = data[p].filter(e =>
e.recurring &&
e.note.toLowerCase() === latestActualEntry.note.toLowerCase() &&
e.isPersonal === latestActualEntry.isPersonal &&
getMonthNum(e.month) <= getMonthNum(targetMonthKey) &&
                            !e.isProjected // Only consider actual entries as templates
                        ).sort((a, b) => getMonthNum(a.month) - getMonthNum(b.month)).pop();
if (templateEntry) {
data[p].push({
uuid: generateUUID(),
month: targetMonthKey,
amount: templateEntry.amount,
note: templateEntry.note,
logo: templateEntry.logo,
recurring: true,
isPersonal: templateEntry.isPersonal,
isProjected: true // Mark as projected
                            });
changed = true;
                        }
                    }
                }
            }
        });
    });
if (changed) {
// Sort entries chronologically after all additions
data.francis.sort((a, b) => getMonthNum(a.month) - getMonthNum(b.month) || a.uuid.localeCompare(b.uuid));
if (data.fiona) {
data.fiona.sort((a, b) => getMonthNum(a.month) - getMonthNum(b.month) || a.uuid.localeCompare(b.uuid));
        }
save();
    }
}
function toggleExpenseChart(toggleButtonElement, uuid) {
// Do not allow expanding charts in edit mode
if (editMode) return;
const chartWrapper = document.getElementById(`expenseChartWrapper_${uuid}`);
const chevronIcon = toggleButtonElement.querySelector('i');
if (chartWrapper.style.display === 'none') {
chartWrapper.style.display = 'block';
toggleButtonElement.classList.add('expanded');
const expense = getExpenseByUUID(uuid);
if (expense) {
drawExpenseHistoryChart(expense, `expenseChartCanvas_${uuid}`, uuid);
    } else {
console.error("Expense not found for chart with UUID:", uuid);
    }
  } else {
chartWrapper.style.display = 'none';
toggleButtonElement.classList.remove('expanded');
if (expenseChartInstances[uuid]) {
expenseChartInstances[uuid].destroy();
delete expenseChartInstances[uuid];
    }
  }
}
// FIXED: getExpenseHistoryData to respect actual start month for chart display
function getExpenseHistoryData(currentExpense, personKey, year) {
const amountsByMonth = new Array(12).fill(0);
const yearPrefix = year.toString();
const expenseIsPersonal = currentExpense.isPersonal;
let chartSeriesStartMonthIndex = 0; // Default to January
let matcher;
if (currentExpense.recurring) {
  matcher = e => e.recurring && e.note.toLowerCase() === currentExpense.note.toLowerCase() && e.isPersonal === expenseIsPersonal;
// For recurring, find the *actual* first occurrence of this series
// Filter by !e.isProjected to only consider actual entries for the true start
const allActualSeriesExpenses = data[personKey].filter(e =>
matcher(e) && !e.isProjected
        ).sort((a, b) => getMonthNum(a.month) - getMonthNum(b.month));
if (allActualSeriesExpenses.length > 0) {
const seriesFirstActualMonthKey = allActualSeriesExpenses[0].month;
const [firstActualYear, firstActualMonthAbbr] = seriesFirstActualMonthKey.split('-');
if (parseInt(firstActualYear) === year) {
chartSeriesStartMonthIndex = MONTHS.indexOf(firstActualMonthAbbr);
            } else if (parseInt(firstActualYear) > year) {
// If the actual start is in a future year, then nothing should be displayed for this year
chartSeriesStartMonthIndex = 12; // Effectively no data for this year
            }
// If firstActualYear < year, chartSeriesStartMonthIndex remains 0 (starts from Jan)
        } else {
// This case implies currentExpense is recurring, but there are no other *actual* entries for its series.
// So, currentExpense itself (if actual) is the first actual entry for the purpose of this chart.
// If currentExpense itself is projected, this path should not be taken, but as a fallback:
const [currentExpenseYear, currentExpenseMonthAbbr] = currentExpense.month.split('-');
if (parseInt(currentExpenseYear) === year) {
chartSeriesStartMonthIndex = MONTHS.indexOf(currentExpenseMonthAbbr);
            } else if (parseInt(currentExpenseYear) > year) {
chartSeriesStartMonthIndex = 12; // No data for this year
            }
// If currentExpenseYear < year, chartSeriesStartMonthIndex remains 0
        }
    } else {
// For one-off expenses, only the month of the expense itself should show
  matcher = e => e.uuid === currentExpense.uuid;
const [currentExpenseYear, currentExpenseMonthAbbr] = currentExpense.month.split('-');
if (parseInt(currentExpenseYear) === year) {
chartSeriesStartMonthIndex = MONTHS.indexOf(currentExpenseMonthAbbr);
        } else {
chartSeriesStartMonthIndex = 12; // No data for this year
        }
    }
// Collect all entries (actual and projected) for the chart year and series
const entriesForChartYearAndSeries = data[personKey].filter(e => {
const expenseYear = e.month.substring(0, 4);
return expenseYear === yearPrefix && matcher(e);
    });
// Populate amountsByMonth
entriesForChartYearAndSeries.forEach(e => {
const monthIndex = MONTHS.indexOf(e.month.substring(5, 8));
if (monthIndex !== -1) {
amountsByMonth[monthIndex] += e.amount;
        }
    });
// Zero out months before the determined start for the chart
for (let i = 0; i < chartSeriesStartMonthIndex; i++) {
amountsByMonth[i] = 0;
    }
return amountsByMonth;
}
function drawExpenseHistoryChart(expense, canvasId, uuid) {
const ctx = document.getElementById(canvasId);
if (expenseChartInstances[uuid]) {
expenseChartInstances[uuid].destroy();
  }
const amounts = getExpenseHistoryData(expense, activePerson, activeYear);
expenseChartInstances[uuid] = new Chart(ctx, {
type: 'bar',
data: {
labels: MONTHS,
datasets: [{
data: amounts,
backgroundColor: (context) => {
if (expense.isPersonal) {
return activePerson === 'francis' ? 'rgba(10, 132, 255, 0.5)' : 'rgba(255, 55, 95, 0.5)';
          } else {
return activePerson === 'francis' ? '#0a84ff' : '#ff375f';
          }
        },
borderColor: 'transparent',
borderRadius: 4,
barPercentage: 0.8,
categoryPercentage: 0.8
      }]
    },
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
display: false
        },
tooltip: {
callbacks: {
label: function(context) {
let label = context.dataset.label || '';
if (label) {
label += ': ';
              }
if (context.parsed.y !== null) {
label += new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(context.parsed.y);
              }
return label;
            }
          },
titleColor: 'white',
bodyColor: 'white',
backgroundColor: 'rgba(27, 27, 32, 0.8)'
        }
      },
scales: {
x: {
grid: {
display: false,
          },
ticks: {
color: 'white',
font: {
size: 10
            }
          }
        },
y: {
beginAtZero: true,
grid: {
color: '#2a2a31',
          },
ticks: {
color: 'white',
font: {
size: 10
            },
callback: function(value) {
return '£' + value.toFixed(0);
            }
          }
        }
      }
    }
  });
}
// Multi-select/Multi-delete functions
function toggleEditMode() {
editMode = !editMode;
selectedExpenses = [];
updateAll();
}
function cancelEditMode() {
editMode = false;
selectedExpenses = [];
updateAll();
}
function toggleExpenseSelection(checkboxElement, uuid) {
if (checkboxElement.checked) {
if (!selectedExpenses.includes(uuid)) {
selectedExpenses.push(uuid);
    }
  } else {
selectedExpenses = selectedExpenses.filter(id => id !== uuid);
  }
renderExpenseHeader();
}
function toggleSelectAll() {
const expensesForMonth = data[activePerson].filter(e => normalizeMonthKey(e.month) === activeMonth);
const allUUIDsForMonth = expensesForMonth.map(e => e.uuid);
const allCurrentlySelected = allUUIDsForMonth.length > 0 && allUUIDsForMonth.every(uuid => selectedExpenses.includes(uuid));
if (allCurrentlySelected) {
// Deselect all
selectedExpenses = selectedExpenses.filter(uuid => !allUUIDsForMonth.includes(uuid));
  } else {
// Select all
allUUIDsForMonth.forEach(uuid => {
if (!selectedExpenses.includes(uuid)) {
selectedExpenses.push(uuid);
      }
    });
  }
renderExpenses();
renderExpenseHeader();
}
function confirmDeleteSelected() {
if (selectedExpenses.length === 0) {
alert("No expenses selected for deletion.");
return;
  }
const actualSelected = [];
const projectedSelected = [];
selectedExpenses.forEach(uuid => {
const expense = getExpenseByUUID(uuid);
if (expense) {
if (expense.isProjected) {
projectedSelected.push(uuid);
      } else {
actualSelected.push(uuid);
      }
    }
  });
if (projectedSelected.length > 0) {
alert("You have selected projected expenses. Projected expenses cannot be deleted directly. Please deselect them or delete their actual entry to stop their projection.");
return;
  }
// If we reach here, all selected expenses are actual (not projected).
// Now, determine if any of them are recurring.
const hasActualRecurringSelected = actualSelected.some(uuid => {
const expense = getExpenseByUUID(uuid);
return expense && expense.recurring;
  });
let confirmationMessage = `Are you sure you want to delete ${actualSelected.length} selected expense(s)?`;
if (hasActualRecurringSelected) {
confirmationMessage += "\n\n(Note: If any of these are recurring, only the selected occurrence(s) will be deleted, not future ones. To stop a recurring series, use the single delete button on one of its actual entries.)";
  }
if (!confirm(confirmationMessage)) {
return;
  }
// Delete only the selected actual expenses.
data[activePerson] = data[activePerson].filter(e => !actualSelected.includes(e.uuid));
save();
cancelEditMode(); // This will also trigger updateAll()
}
function updateAll() {
renderYears();
renderMonths();
applyRecurring(); // This must run before updateChart and renderExpenses
updateViewModeText();
updateChart();
updateBalance();
renderExpenseHeader();
renderExpenses();
}
// Initial setup calls
migrateData();
normalizeExpenseData();
updateLogosForAllExpenses();
updateAll();
</script>
</body>
</html>
